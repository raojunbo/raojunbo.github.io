
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  北哥传奇
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="北哥传奇" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">北哥传奇</a></h1>
  
    <h2></h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:raojunbo.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15512048926912.html">设计模式系列（四）-- 行为型</a></h1>
			<p class="meta"><time datetime="2019-02-27T02:14:52+08:00" 
			pubdate data-updated="true">2019/2/27</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>具体的实现Demo请进入<a href="https://github.com/raojunbo/DesignPatterns.git">DesignPatterns iOS工程实现</a>查看</p>

<h2 id="toc_0">13. 责任链模式</h2>

<p>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些<br/>
对象连接成一条链，并且沿着者条链传递请求，直到有对象处理它为止。<br/>
<strong>iOS里的事件传递。就是一种责任链模式</strong>。<br/>
使用场景<br/>
有多个对象可以处理一个请求，具体哪个对象处理该请求由运行时自动确定。<br/>
在不确定指定接收者的情况写，向多个对象中的一个提交一个请求。</p>

<h2 id="toc_1">14：命令模式(很重要)</h2>

<p>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。<br/>
使用场景<br/>
需要对<strong>行为进行记录</strong>，<strong>撤销</strong>或者重做，事物等的处理时。凡是有命令的地方，都可以使用命令模式。命令模式实现了很容易对命令的扩展（即对扩展开放），添加一个命令就可以了，同过这些命令取修改接受者的状态，其实我们直接执行函数就可以修改接受者的状态，当我们需要添加一些行为的记录，撤销的等行为，为了将行为的<strong>实现者receiver</strong>与行为的请求者(既可以是receiver也可以是其他对象)实现松耦合。</p>

<h2 id="toc_2">15：解释器模式</h2>

<h2 id="toc_3">16：迭代器模式</h2>

<p>提供一种按顺序访问一个聚合对象中的各个元素。而又无需暴露该对象的内部表示。<br/>
迭代器的关键代码是实现hasNext,next。<br/>
迭代器简化并且统一了对于集合类型的访问方法。在新添加的集合类型里，无需修改原有代码，只需要实现针对这个心添加的集合的迭代器就可以了。所以对扩展时开放的。</p>

<h2 id="toc_4">17：中介者模式</h2>

<p>中介者模式和我们日常生活中的中介者其实是一样的。房产中介。解决了买家与卖家之间错综复杂的关系。实现了。买家与中介联系，卖家与中介联系,当然这里协调的对象也可以是相同类型的比如都是&quot;买家&quot;,我们把买家与卖家统一称为“同事”（这类在初看文章的时候不理解为什么都是”同事“，其是为了方便描述罢了。在实际的开发中，那你想协调哪两种或者多种对象之间的交互都是可以的）。在对象的世界里面，也是如此。<br/>
实际的例子<br/><br/>
MVC里的模式，c就是中介者，m,v都是同事。c需要协调m与v的交互。那么从这里也可以看出。设计不当的时候很容易将c搞的比较复杂。<br/>
代码里的例子<br/>
 同事之间有一定的关系。同事A修改的分值，同事B的分值同样会修改。同事C的值统一会修改。<br/>
那么就有个问题，我同事A修改了值，我还要通过A取修改B的值，B的值修改了，B还要去修改C的值。这样就是对象间非常复杂的操作关系。<br/>
引入中介这后，这个几个对象之间的关系就变成只有中介者之间交互。这样关系就轻松多了。</p>

<h2 id="toc_5">18：备忘录模式</h2>

<p>保存一个对象的某个状态，以便在适当的时候恢复对象。<br/>
在不破话封装的前提下，捕获一个对象的内部状态，幷在该对象之外保存这个状态，这样可以<br/>
在以后将恢复到原先保存的状态。<br/>
实现代码的核心是搞一个备忘录的类。要保存状态的类可以实现协议方法，取出当前需要保存的<br/>
信息。和将保存的信息恢复为类的过程。整个是在需要备忘得对象实现的。<br/>
所以，备忘录其实，就时搞一个类专门实现“存”与&quot;取&quot;一个对象的状态，以备忘。</p>

<h2 id="toc_6">19：观察者模式</h2>

<p>当一个对象的状态发生改变的时候，所有的依赖对象都将得到通知。<br/>
解决一对多的情况。<br/>
观察者模式，在iOS里到处都有。通知中心，Kvo,等.</p>

<h2 id="toc_7">20：状态模式(很重要,实际的开始中很常见)</h2>

<p>对象的行为依赖于他的状态，并且可以根据它的状态的改变而改变相关的行为。<br/>
使用场景<br/>
当代码中包含有大量于状态有关的行为时。</p>

<h2 id="toc_8">21：策略模式</h2>

<p>策略模式同状态模式一样，不同的是将策略进行隔离。当有新的策略时，只需要扩展新的策略就行了。</p>

<h2 id="toc_9">22：模板方法模式</h2>

<h2 id="toc_10">23：访问者模式</h2>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15512048797799.html">设计模式系列（三）-- 结构型</a></h1>
			<p class="meta"><time datetime="2019-02-27T02:14:39+08:00" 
			pubdate data-updated="true">2019/2/27</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>具体的实现Demo请进入<a href="https://github.com/raojunbo/DesignPatterns.git">DesignPatterns iOS工程实现</a>查看</p>

<h2 id="toc_0">6. 适配器模式</h2>

<p>适配器模式将某个类的接口转换成客户端期望的另一个接口表示。目的是消除由于接口不匹配所造成的类的兼容性问题。分为3类，类适配器，对象的适配器</p>

<ol>
<li><p>类适配器<br/>
所谓的类适配器，指的是适配器Adapter<strong>继承</strong>我们的被适配者Adaptee，并实现目标接口Target。</p></li>
<li><p>对象适配器<br/>
所谓的对象适配器，就是适配器实现我们的接口，但是并不继承需要被适配的类。而是通过在构造函数中将需要被适配的类传递进来从而进行适配(也就是组合的形式)。</p></li>
</ol>

<p>它们的特点(至于特点，可以从它们的实现方法取考虑)<br/>
类适配器只能适配一个类，而对象适配器可以将不同的待适配者适配到统一目标。<br/>
而类适配器由于是继承，可以置换待适配对象的一些方法。</p>

<h2 id="toc_1">7. 外观模式</h2>

<p>外观模式让子系统更加易用，使用端不需要了解子系统的内部的实现。<br/>
也不需要跟众多子系统的内部的模块进行交互，只需要跟门面交互就可以了。外观角色好比一道屏障，对客户端屏蔽了子系统的具体实现。</p>

<h2 id="toc_2">8. 桥接模式</h2>

<p>桥接模式的场景：<br/>
类似于绘制形状，有多个形状，每个形状的颜色还不一样。为每种形状都提供各种颜色的版本，会造成n*n个类。</p>

<p>这是可以采用桥接模式，将<strong>继承关系转换成关联</strong>关系，为每种形状都提供各种颜色的版本。<br/>
桥接模式的本质是将继承关系转换成关联的关系。从而降低了类与类之间的耦合度，减少了系统中的类的数量，也减少了代码量。</p>

<h2 id="toc_3">9. 装饰</h2>

<p>有这样一个场景，购买咖啡时，可以要求在其中加入各种调料。例如<br/>
豆浆，摩卡，蒸奶，有时添加，有时不添加。这样就会导致类的爆炸，并且无法满足混合添加,多次添加的的情况。<br/>
关键的实现装饰类的实现</p>

<p>装饰类的设计，装饰类既有主类的属性，本类也是主类类型。这样可以递归的方式来获得最总被装饰了的对象。</p>

<h2 id="toc_4">10. 代理</h2>

<p>代理不说了，开始做iOS时就是代理模式。</p>

<h2 id="toc_5">11. 享元</h2>

<p>享元就是共享对象。既可以内存缓存对象，也可复用对象（通过一个唯一的标识）。</p>

<h2 id="toc_6">12. 组合模式</h2>

<p>我的理解，组合的设计模式在这里有两层含义。<br/>
一层含义：对象包含对象的问题，通过组合的方式（在对象内部引用对象）来进行布局。<br/>
二层含义：引申到树形结构的对象包含对象。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15512048653711.html">设计模式系列（二）--创建型设计模式</a></h1>
			<p class="meta"><time datetime="2019-02-27T02:14:25+08:00" 
			pubdate data-updated="true">2019/2/27</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>接下来将进入设计模式里的创建型设计模式。这里将对设计模式的使用场景与优劣，以及UML图做描述。<br/>
具体的实现Demo请进入<a href="https://github.com/raojunbo/DesignPatterns.git">DesignPatterns iOS工程实现</a>查看</p>

<h2 id="toc_0">0. 简单工厂（if type）</h2>

<p>（通过传类型进行区分，对修改是开放的，所有不好）<br/>
简单工厂就是一个工厂，将类型传进去，在一个类里面生成不同的类型。<br/>
弊端：这个工厂会包括多个需要生产的产品的引用。而且对于修改是开放的，因为需要修改类里面的内容。对于扩展也是需要在同一个类里面做修改。</p>

<h2 id="toc_1">1. 工厂方法（一个产品线）</h2>

<p>使用场景：<br/>
当需要创建多种分Type的对象时，特别是针对多种类型有共同的行为特征时。或者写出简单工厂时，思考是否可以用工厂方法。</p>

<p>好处：<br/>
工厂方法遵循开闭原则就是”对扩展开放，对修改关闭”，再说白点就是实现工厂方法以后要进行扩展时不需要修改原有代码（你看简单工厂里添加类型时时不是还要修改if语句），只需要增加一个<strong>工厂实现类</strong>和<strong>产品实现类</strong>就可以。</p>

<p>实现：<br/>
产品基类（协议），工厂基类(协议)。产品实现，工厂实现。客户端直接使用工厂生产相应的产品就可以了。</p>

<p>费曼<strong>工厂方法会针对每个产品都有一个工厂实现类</strong>。工厂实现类有一个相应工厂的一个实现，这个实现是生产产品的实现。我们可以将工厂方法理解成一个产品线。</p>

<h2 id="toc_2">2. 抽象工厂（多个产品线及真正的工厂）</h2>

<p>使用场景<br/>
1.通过对象组合创建抽象产品<br/><br/>
2.创建多个系列产品<br/>
3.必须修改父类的接口才能支持新的产品</p>

<p>费曼  <strong>所谓的抽象工厂，就是将工厂方法的产品线扩大到多个产品线</strong> 我们可以将抽象工厂理解成多条产品线（真正的工厂）,每一个工厂有其特殊的标识。</p>

<p>突然想到一个例子<br/>
”北京杂酱面“ 与 “重庆杂酱面”都是杂酱面，都是配料都是面条，汤，酱，但北京面馆（一个工厂），是北京面条，北京汤，北京酱，重庆面馆（一个工厂）是重庆面条，重庆汤，重庆酱，这个工厂是一个产品线。</p>

<h2 id="toc_3">3. 单例模式(整个应用程序只用一个对象)</h2>

<p>使用场景<br/>
在一个应用程序中，当需要在多个地方共享数据时</p>

<p>注意点<br/>
注意多线程的使用下的情况。</p>

<p>在实际的使用中，单例模式也不能滥用。举个例子，单例有个isLogin，我判定isLogin为true进入一个操作，其他线程将isLogin改成false，那么在这个单例里执行的操作都将有问题。<br/>
因为数据被其他线程改变了。在实际的开发中，这种情况会是一个大坑。</p>

<h2 id="toc_4">4. 构建者(子部分算法的变化无常，当构成这个对象组成相对固定)</h2>

<p>构建者模式使用多个简单的对象一步一步构建一个复杂的对象。<br/>
<strong>主要解决的问题，有时候面临着&quot;一个复杂的对象&quot;的创建工作，通常其子对象部分有着剧烈的变换，需要将他们组合在一起</strong>。</p>

<p>我的理解是，当创建一个对象，这个对象需要很多组合的对象（且这些组合的对象有一定固定算法，我需要将这些对象随意的组合成我需要的对象）时，用构建者模式。（区别与抽象工厂，抽象工厂创建后不是随意的组合，是工厂创建后就只能生产固定的产品了，抽象工厂的变换在外部，而构建者的变换在内部，哈哈，就是这个意思）<br/>
例如<br/>
构造电脑，电脑的组成由CPU,显示器，主板，这是相对固定的。但子部分，CPU有各种实现的算法。所以这种情况使用构建者最好。</p>

<h2 id="toc_5">5. 原型模式</h2>

<p>原型模式<br/>
原型遵循copy或者clone的协议。执行copy或者clone就是按照原型创建一个对象。在iOS里理解成copy就行了。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15512048416439.html">设计模式系列（一）设计模式概要</a></h1>
			<p class="meta"><time datetime="2019-02-27T02:14:01+08:00" 
			pubdate data-updated="true">2019/2/27</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在这里给大家推荐一本设计模式入门的书《HeadFirst 设计模式》，这是我真正理解设计模式的开始。当然对于设计模式的理解，需要一定的开发经验才能真正理解的。<br/>
<img src="https://github.com/raojunbo/picres/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-02%2012.50.34.png?raw=true" alt="image"/><br/>
本篇文章不是对设计模式的全解。而是我自己在iOS的实践中对设计模式的理解的一个一个梳理。我在<a href="https://github.com/raojunbo/DesignPatterns.git">DesignPatterns iOS工程实现</a>里写出了相关的<a href="https://github.com/raojunbo/DesignPatterns.git">Demo</a></p>

<p>学习方法：抽象—》具体—》应用—》引申。重点在与理解设计模式的几大原则在设计模式里的体现。当你理解了几大原则在设计模式里的体现，也就理解了设计的精髓所在。在自己写出相关Demo后，然后自己默写出相关设计模式的UML图，分析每种设计模式的优劣是为解决什么问题而诞生。那么那你就真正理解了设计模式。</p>

<h2 id="toc_0">设计模式的六大原则</h2>

<ol>
<li><p>开闭原则（面向对向设计的首要目标:<strong>对扩展开放，对修改关闭</strong>）<br/>
对扩展开放，对修改关闭，也就是在进行扩展时，不要对先前的代码修改（因为如果对先前的代码进行修改的化，需要重新测试）。对扩展开放最好直接创建一个新类，其他的东西都不要更改。可以采用抽象的方式，将对象抽象出来，形成对这个&quot;抽象化&quot;处理。</p></li>
<li><p>里氏替换原则（<strong>子类替换基类业务不受影响</strong>）<br/>
在软件中将一个基类对象替换成它的子类对象，程序不将不会出现任何差错。其实这是开闭原则的一个实现。也就是在程序中尽量使用基类类型来对对象进行定义，而运行时在确定其子类类型。这样有一种<strong>面向基类，面向协议编程</strong>，这样在有扩展进来时，更改的代码就会很少。</p></li>
<li><p>依赖倒置原则(<strong>面向协议编程</strong>)<br/>
名字取的很高大上。实际就一句话，实现依赖抽象，抽象不依赖实现。也就是面向协议编程，不针对实现编程。</p></li>
<li><p>接口隔离原则(<strong>接口分离</strong>)<br/>
使用多个专门的接口，而不使用单一的总接口。每个接口<br/>
应该承担一种相对独立的角色，将不同功能类型的接口进行分离</p></li>
<li><p>迪米特法则（<strong>减少对象之间交互</strong>）<br/>
应该减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应该发生任何直接的作用。</p></li>
<li><p>合成复用原则（<strong>多用组合少用继承</strong>）<br/>
尽量使用合成与聚合，而不是使用继承。<br/>
这条在实际的开发中，的确很有感触。继承用的不好会导致维护的困难。</p></li>
</ol>

<h2 id="toc_1">设计模式分类</h2>

<p>创建型设计模式<br/>
结构型设计模式<br/>
行为型设计模式</p>

<h3 id="toc_2">一：创建型（5种）</h3>

<p>1:单例模式<br/>
2:工厂方法(生成单一产品)<br/>
3:抽象工厂（生产系列产品）<br/>
4:建造模式（生产比较复杂的具有统一生产流程的产品，将生产流程固话）<br/>
5:原型设计模式(clone的实现)</p>

<h3 id="toc_3">二：结构型（7种）</h3>

<p>6:适配器模式（将一个对象适配成需要的接口）<br/>
7:桥接模式<br/>
8:组合模式（类似于iOS里的view，对每一个组件具有相同的操作方法）<br/>
9:外观模式（子系统）<br/>
10:享元模式（聚合使用）<br/>
11:代理模式<br/>
12:装饰模式</p>

<h3 id="toc_4">三：行为型（11种）</h3>

<p>13:责任链模式<br/>
14:命令模式<br/>
15:解释器模式（暂时不太明白）<br/>
16:迭代器模式<br/>
17:中介者模式<br/>
18:备忘录模式<br/>
19:观察者模式<br/>
20:状态模式<br/>
21:策略模式<br/>
22:模板方法模式<br/>
23:访问者模式(暂时不太明白)</p>

<p>其中，命令模式，状态模式，策略模式，都是同的思想，将命令封装，将状态封装，将策略封装。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15512046578708.html">Swift梳理</a></h1>
			<p class="meta"><time datetime="2019-02-27T02:10:57+08:00" 
			pubdate data-updated="true">2019/2/27</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">一：基础知识</h2>

<h4 id="toc_1">1. Float与Double有时在比较是比如1.2与1.2的比较为什么表示时不相等?</h4>

<h4 id="toc_2">2. 元组主要是解决什么问题的？</h4>

<h3 id="toc_3">变量定义与数</h3>

<ul>
<li><p>数<br/>
Int，Float,Double<br/>
同其他语言一样，Int是机器字长。32位长度的Float，64位的Double;小数的表示都是用科学计数法表示。所以64位的Double的精度要高。</p></li>
<li><p>常量与变量</p></li>
</ul>

<pre><code>var population:Int = 100;
var price:Float = 100.0;
let address:String = &quot;潜江&quot;;
</code></pre>

<h3 id="toc_4">if语句,循环语句</h3>

<pre><code>//if语句示例
var population = 20;
let name:String = &quot;raojunbo&quot;;
if (population &lt; 50 ){
    print(&quot;20018:\(name)人口小于\(population)&quot;);
}else{
    print(&quot;2018:\(name)人口超标了&quot;);
}
population = 100;
if(population &lt; 50){
    print(&quot;20019:\(name)人口小于\(population)&quot;);
}else{
    print(&quot;2019:\(name)人口超标了&quot;);
}
</code></pre>

<pre><code>//switch语句示例
var statusCode:Int = 404;
var statusString:String = &quot;潜江市&quot;;

switch statusCode {
    case 400:
        statusString = &quot;很好&quot;;
    case 401:
        statusString = &quot;一般&quot;;
    default:
        statusString = &quot;默认&quot;;
}
print(statusString);
</code></pre>

<pre><code>//while循环
var i:Int = 0;
while (i &lt; 10 ){
    print(i);
    i+=1;
}

</code></pre>

<pre><code>//for 循环
var i:Int = 0;
for i in 2...6 {
    print(i);
}

</code></pre>

<h3 id="toc_5">元组（Swift特有）</h3>

<pre><code>//有点类似于Object-C里的字典，主要是在返回参数时，可以同时返回两个参数
var statusCode:Int = 404;
var statusString:String = &quot;这是状态错误&quot;;
let error = (statusCode,statusString);
let error2 = (code:statusCode,error:statusString);
print(&quot;\(error.0),\(error.1)&quot;);
print(&quot;\(error2.code),\(error2.error)&quot;)
</code></pre>

<h3 id="toc_6">字符串</h3>

<p>Swift字符串的字符都是Character类型，Swift的Character类型表示Unicode字符。组合起来就是字符串的实例</p>

<ul>
<li>Unicode</li>
</ul>

<h3 id="toc_7">可空类型（Swift特有）</h3>

<p>Swift可空类型让这门语言更加安全，（有点类似于NSObject里的weak属性）一个可能为nil的实例应该被声明为可空类型。在Swift的变量必须给定一个初始值，否则编译不过。也可声明成一个可空类型。<strong>任何变量类型都可以用可空类型来说明一个实例可能是nil。哪怕是一个Int类型，而NSObject只能允许对象是nil</strong></p>

<ul>
<li>可空类型定义</li>
</ul>

<pre><code>var errorStr = String?;
print(errorStr);
</code></pre>

<ul>
<li>可空类型绑定</li>
</ul>

<p><strong>将可空变量的真实存在的值赋值给另一个变量，即绑定;绑定的过程也是展开的过程</strong></p>

<pre><code>var play:Int?
if let w = play {
    print(w);
}
//将可空的play绑定到w变量上。是空，不做任何操作，不为空就给w;
</code></pre>

<ul>
<li>可空链式调用</li>
</ul>

<pre><code>var errorCodeString:String?
errorCodeString = &quot;404&quot;;
var upperCodeString = errorCodeString?.uppercased();//链式调用
</code></pre>

<ul>
<li>nil合并运算符</li>
</ul>

<pre><code>var errorDescription:String?;
let description = errorDescription ?? &quot;error&quot; 
</code></pre>

<h2 id="toc_8">二：容器类型</h2>

<h3 id="toc_9">数组</h3>

<p>这里的数组里的类型必须是相同类型</p>

<pre><code>//数组定义，添加元素，删除元素
var bucketList:[String] = [&quot;rao&quot;,&quot;jun&quot;];
bucketList.append(&quot;bo&quot;)
bucketList.append(&quot;nihao&quot;)
bucketList.removeLast();
for item in bucketList {
    print(item)
}
</code></pre>

<blockquote>
<p>注意<br/>
是用<code>let bucketlist申明的是不可变的数组，是用var申明的是可变的数组</code></p>
</blockquote>

<h3 id="toc_10">字典</h3>

<pre><code>var movieDict = [&quot;rao&quot;:1,&quot;jun&quot;:2,&quot;bo&quot;:3];//申明
movieDict[&quot;qing&quot;] = 4//设置
movieDict.removeValue(forKey: &quot;qing&quot;)//移出key=qing的值
var keyArray = movieDict.keys;//全部的key值
for item in keyArray {
    print(item)
}

</code></pre>

<blockquote>
<p>注意<br/>
不可变的字典就是用let修饰</p>
</blockquote>

<h3 id="toc_11">集合</h3>

<h3 id="toc_12">函数</h3>

<pre><code>func printPersonGreeting2 (to name:String, price:Double,age:Int = 20) {
    print(&quot;\(name),\(price),\(age)&quot;);
}

printPersonGreeting2(to: &quot;rao&quot;, price: 20.0);
printPersonGreeting2(to: &quot;jun&quot;, price: 30.0, age: 10);
</code></pre>

<ul>
<li><p>参数</p>

<p>一个方法可以定义多个参数，但调用的时候，可以调用这个函数的其他参数的形式。</p>

<p>函数在定义的时候，有内部参数与外部参数，内部参数是供內使用的，外部参数是供调用时使用的。在定义时也可以特别标记没有外部参数，在需要通过函数内部修改外部的值时，需要标记这个参数inout;</p></li>
<li><p>函数返回</p></li>
</ul>

<pre><code>//返回一个元组
func sortedEvenOddNumbers(numbers:[Int])-&gt;(events:[Int],odds:[Int]) {
    var evens = [Int]();
    var odds = [Int]();
    for number in numbers {
        if(number%2==0){
            //是偶数
            evens.append(number);
        }else{
            //是奇数
            odds.append(number);
        }
    }
    return (evens,odds);
}

let array = [10,1,4,3,43,85,27];
let tupe = sortedEvenOddNumbers(numbers: array);

print(tupe.events)
print(tupe.odds)
</code></pre>

<pre><code>//返回可空类型
func gradMiddleName(fromFullName name:(String, String?, String))-&gt;String?{
    return name.1;
}
var middle = gradMiddleName(fromFullName: (&quot;rao&quot;,nil,&quot;bo&quot;))
if let middleName = middle {
    print(middleName);
}
</code></pre>

<ul>
<li>函数类型</li>
</ul>

<p><code>func sortedEvenOddNumbers(numbers:[Int])-&gt;(events:[Int],odds:[Int])</code></p>

<p>上面这个函数的类型，就是([Int])-&gt;([Int],[Int])，函数也可以当做一个变量存储。</p>

<pre><code>func sortedEvenOddNumbers(numbers:[Int])-&gt;(events:[Int],odds:[Int]) {
    var evens = [Int]();
    var odds = [Int]();
    for number in numbers {
        if(number%2==0){
            //是偶数
            evens.append(number);
        }else{
            //是奇数
            odds.append(number);
        }
    }
    return (evens,odds);
}

let evenOdsFunction:([Int])-&gt;([Int],[Int]) = sortedEvenOddNumbers;//将一个函数用一个变量承接起来
let array = [10,1,4,3,43,85,27];
var evenOdds = evenOdsFunction(array);
print(evenOdds)
</code></pre>

<h3 id="toc_13">闭包</h3>

<p>函数实际上是闭包的一种。<br/>
所有的函数实际上是一种闭包。暂时将闭包理解成一个匿名函数。</p>

<ul>
<li>闭包的表达式语法</li>
</ul>

<pre><code>//函数形式
let volunteerSorted = [1,3,40,32,2,77,13];
func sortAscending(_ i:Int, _ j:Int)-&gt;Bool {
    return i &lt; j;
}
let volunteer = volunteerSorted.sorted(by: sortAscending);

//闭包完整形式
let volunteer2 = volunteerSorted.sorted { (i:Int, j:Int) -&gt; Bool in
    return i&lt;j;
}

//闭包的缩略形式1
let volunteer3 = volunteerSorted.sorted { (i, j) -&gt; Bool in
     return i&lt;j;
}

//闭包的x缩略形式2
let volunteer4 = volunteerSorted.sorted(by: {$0 &lt; $1});
</code></pre>

<ul>
<li><p>函数作为返回值</p>

<pre><code>let volunteerCount = [1,3,40,32,2,53,77,13]
func makeTownGrand()-&gt;(Int,Int)-&gt;Int {
func buildRoads(lightsz:Int,existingLights:Int)-&gt;Int{
    if(lightsz == existingLights){
        return 0
    }else if(lightsz &gt; existingLights){
        return lightsz;
    }else {
        return existingLights;
    }
}
return buildRoads;
}                          
var result = makeTownGrand();//result是一个函数
print(result(10,10));

</code></pre></li>
<li><p>函数作为参数</p></li>
<li><p>闭包能捕获变量</p></li>
<li><p>闭包是引用类型</p></li>
<li><p>函数式编程                                                        </p></li>
</ul>

<h3 id="toc_14">结构体</h3>

<h3 id="toc_15">类</h3>

<h2 id="toc_16">三：高级内容</h2>

<h3 id="toc_17">协议</h3>

<h3 id="toc_18">扩展</h3>

<h3 id="toc_19">泛型</h3>

<h3 id="toc_20">错误处理</h3>

<h2 id="toc_21">四：内存管理和ARC</h2>

<h2 id="toc_22">五：Object-C与Swift的交互</h2>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15511053969907.html">威科夫中阶课程（六）</a></h1>
			<p class="meta"><time datetime="2019-02-25T22:36:36+08:00" 
			pubdate data-updated="true">2019/2/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	

		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15509867976030.html">威科夫中阶课程（五）</a></h1>
			<p class="meta"><time datetime="2019-02-24T13:39:57+08:00" 
			pubdate data-updated="true">2019/2/24</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">UTAD/UT</h2>

<ul>
<li>Spring的反面
UPAT是Spring的反面</li>
<li>UTAD
在刺穿阻力时，有成交量的上升，就是一种很好的UTAD</li>
</ul>

<p>越快速回来（价差宽），成交量很大，越看空<br/>
其分析其实和Spring是一样的。<br/>
只不过Spring是想下为努力失败<br/>
UTAP是想上为努力失败</p>

<h2 id="toc_1">1. 供给分析的元素（很重要）</h2>

<ul>
<li><p>价差<br/>
K线最高价和最低价之间的幅度，反映运动的难易程度和结果；宽的话结果好些。</p></li>
<li><p>成交量<br/>
单位时间成交的买盘或卖盘数量，反映买盘或卖盘付出的力量；</p></li>
<li><p>k线摆动<br/>
价格如何从开盘运动到收盘结束；</p></li>
<li><p>收盘价<br/>
收盘价的变动，揭示了对应买盘或者卖盘所取得的成果</p></li>
<li><p>需求<br/>
买盘的力量</p></li>
<li><p>供应<br/>
卖盘的力量</p></li>
<li><p>供求关系<br/>
买盘力量和卖盘力量之间的关系</p></li>
</ul>

<p>威科夫不对一根一根K线做分析，而是对波动作分析。每一波每一波的需求与供应。</p>

<h3 id="toc_2">1.1 价差分析总则（重要）</h3>

<ol>
<li><p>价差增加<br/>
价格行进中，阻力较小<br/>
例如：在收盘价较高时</p>

<ul>
<li>供应下降，需求增加</li>
<li>供应不变，需求增加</li>
<li>供应上升，需求上升的更多</li>
</ul></li>
<li><p>价差减少<br/>
价格行进中有一些阻力</p></li>
<li><p>平均价差 <br/>
表明正常的趋势或者正常的价格行进</p></li>
</ol>

<h3 id="toc_3">1.2 成交量分析总则（重要）</h3>

<ol>
<li><p>一般规则<br/>
成交量表明需求和供应的质量，但通常<strong>我们观察成交量时，更倾向于它代表着的供应的出现或者缺乏，供应是第一位的，其次才是需求</strong></p></li>
<li><p>成交量的增加<br/>
代表着支撑价格运动的力量在增加，或者供求即将改变的迹象，或者只是供应出现的迹象</p></li>
<li><p>高量<br/>
通常表明供应的出现，如果价格想要继续上涨，那么就必须吸收掉这些供应。要么是CO吸收，要么被散户买走</p></li>
<li><p>极高量<br/>
通常是BC</p></li>
<li><p>成交量极少<br/>
支撑价格运动的力量在减少，或者供求其中一方在减少，或者只是供应减少的证据。</p></li>
</ol>

<p>6.低量<br/>
支撑价格运动的力量很小，或者只有很少的供应</p>

<h3 id="toc_4">1.3 成交量分析情况（重要）</h3>

<h4 id="toc_5">上涨市场，价差增加</h4>

<ol>
<li><p>成交量增加<br/>
需求增加，健康的价格向上运动<br/>
如果是极高量，可能是BC</p></li>
<li><p>成交量极少<br/>
轻松反弹<br/>
或则需求减少的迹象，容易引发下跌</p></li>
<li><p>平均成交量<br/>
正常的价格向上运动<br/>
但是成交量应该跟上价差的变化</p></li>
</ol>

<h4 id="toc_6">上涨市场，价差减少</h4>

<ol>
<li><p>成交量增加<br/>
可能有高质量的供应进入，尝试向下反转价格运动</p></li>
<li><p>成交量减少<br/>
需求耗尽，容易产生回落</p></li>
<li><p>平均成交量<br/>
价格运动减速，遇到一些供应，指示价差减少</p></li>
</ol>

<h4 id="toc_7">下跌市场，价差增加</h4>

<ol>
<li>成交量增加
供应增加，健康的价格向下运动
如果是极高量，可能是SC</li>
<li>成交量减少
轻松下跌
或者有供应减少，容易引发反弹</li>
<li>平均成交量
正常的价格向下运动
但是成交量应该要跟上价差的变化</li>
</ol>

<h4 id="toc_8">下跌市场，价差减少</h4>

<ol>
<li>成交量增加
可能有高质量的需求进入，尝试向上反转价格运动</li>
<li>成交量减少
供应耗尽，容易引发反弹</li>
<li>平均成交量
价格运动减速，遇到一些需求</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15508519143583.html">2019年成长时间轴</a></h1>
			<p class="meta"><time datetime="2019-02-23T00:11:54+08:00" 
			pubdate data-updated="true">2019/2/23</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">1. Swift工程化（2月1日-2月30日）</h2>

<pre><code>1. 实践：达到工程实践目标，能用Swift写出一个需求
2. 思考Swift实现的本质
</code></pre>

<h2 id="toc_1">2. iOS从高级到资深（2月30日-4月30日）</h2>

<pre><code>1. 思考：动手写关键的东西，解决关键的问题。
2. 手动重写SDWeb开源框架，看看自己与SD有什么差别
3. 手动重写AF开源框架，看看自己与其的差别
4. 手动重写题型绘制，搞出对图文混排的理解
5. 优化工作，cash奔溃优化，结构优化，性能优化，流程优化
</code></pre>

<h2 id="toc_2">3. 技术领导力（5月1日--6月30日）</h2>

<pre><code>1. 极客时间里的“技术领导力”课程
2. 领导梯度，德鲁克系列，执行力培训
3. 公司的领导力培训
</code></pre>

<h2 id="toc_3">3. 英语阅读能力（5月-12月）</h2>

<pre><code>1. 阅读能力
2. 听力能力
3. 写作能力
4. 培训：还是找一家公司培训下吧
5. 订阅经济学人开始经济阅读之路吧
</code></pre>

<h2 id="toc_4">4. Python，Mysql（6月-6月）</h2>

<pre><code>1. 实践：到达工程实践
2. 用Python写出一个东西，写出一个什么东西，暂时还没想好
</code></pre>

<h2 id="toc_5">5. JS,CSS,React（7月）</h2>

<ol>
<li>实践 达到工程实践 </li>
<li>写一个复杂的前端</li>
</ol>

<h2 id="toc_6">6. 威氏理论（3月-6月）</h2>

<pre><code>1. 已有课程，中阶，高阶，波段课程整理完
2. 进行横向整理，总结出一套自己的套路
2. 开一个公众账号，坚持写自己的分析日报
</code></pre>

<h2 id="toc_7">7. 房产逻辑（7月-8月）</h2>

<pre><code>1. 已有课程，刘德科课程，大胡子课程
2. 形成自己的投资逻辑
3. 房地产的逻辑
</code></pre>

<h2 id="toc_8">8. 阅读计划（全年)</h2>

<pre><code>1. 每月一本书籍的整理输出，即阅读笔记
</code></pre>

<h2 id="toc_9">9. 金融学考研</h2>

<p>咨询相关考研的培训机构，进行相应的计划准备<br/>
1. 基础的经济学原理<br/>
2. 国际金融<br/>
3. 货币银行学<br/>
4. 数学<br/>
5. 英语</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15507609402868.html">威科夫中阶课程（四）</a></h1>
			<p class="meta"><time datetime="2019-02-21T22:55:40+08:00" 
			pubdate data-updated="true">2019/2/21</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">1. 行为，反应和测试</h2>

<p>行为：通常有高波动率，宽价差，高成交量<br/>
 反应：对前面行为的反应，价差，成交量<br/>
 测试：对行为的测试，成交量，低点</p>

<ul>
<li><p>描述动作的因素<br/>
成交量（努力），价差（结果），位置（结果）</p></li>
<li><p>行为理解</p></li>
<li><p>反应理解</p></li>
<li><p>测试理解<br/>
测试最好是更高的地点，并且成交量是低的。如果成交量较大，并且没有下跌到更地点，那么说明供应较大且需求也较大，那么就会进入震荡区，需要进行二次测试。</p></li>
<li><p>前后对比<br/>
通过<strong>前后的行为比较</strong>，<strong>前后反应程度比较</strong>，然后是<strong>前后测试有效度比较</strong>。</p></li>
<li><p>Spring示例<br/><br/>
左侧    向下刺穿支撑<br/>
右侧   Reaction： 反弹<br/>
     Test： 再次回落测试供应</p></li>
</ul>

<h2 id="toc_1">2. Spring的买入点（说实话这里不是很理解）</h2>

<ul>
<li><p>NS(NO Supply)（不是好的买点）<br/>
不好放止损。因为在支撑位置时，很可能是无供应，也无需求，价格的上涨，是需要需求的。很多情况下是阴跌。所以最好是买在需求柱的地方。交易成本较大。</p></li>
<li><p>GBD（更好的买入点）<br/>
需求柱的收盘位置进，止损放在需求柱底部。</p></li>
</ul>

<h2 id="toc_2">3. 趋势线工具</h2>

<p>支撑：需求战胜供应的区域<br/>
阻力：供应战胜需求<br/>
趋势：<br/>
趋势通道<br/>
步幅：在上升通道里，步幅会越来越小，从而上升趋势减速<br/>
1/2回落：回落要在1/2之上</p>

<p>供应线与需求线<br/>
阻力线与支撑线</p>

<h2 id="toc_3">4. 思考路径</h2>

<pre><code>v,p--&gt;s,d--&gt;co--&gt;direction
量价推断--》供应与需求--》推断CO目的--》市场方向
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15503292008544.html">威科夫中阶课程（三）</a></h1>
			<p class="meta"><time datetime="2019-02-16T23:00:00+08:00" 
			pubdate data-updated="true">2019/2/16</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">1. 练习方法</h2>

<p>practice  模拟练习<br/>
case study  案例分享<br/><br/>
paper trade  历史纸上交易（在历史走势里一屏一屏过）<br/>
actual trade  实盘</p>

<h2 id="toc_1">2. 吸筹备忘录</h2>

<h3 id="toc_2">2.1 A段与B段</h3>

<ul>
<li><p>A段和B段的意图</p>

<ul>
<li>A:停止行为</li>
<li>B:测试供应，产生需求，换手，从公众手里换手到CM手里</li>
</ul></li>
<li><p>威科夫原理</p>

<ul>
<li>A:PS,SC,AR,ST</li>
<li>B:UA,ST,ST as SOW</li>
</ul></li>
<li><p>初次支撑PS</p>

<ul>
<li> 停止下跌的第一次尝试</li>
<li> 尝试总是失败，价格会继续走低到SC</li>
</ul></li>
<li><p>SC卖盘高潮 </p>

<ul>
<li>宽价差/高的成交量</li>
<li>例外1 持续走低的SC运动，供应减少</li>
<li>例外2 SC行为可能持续一段时间，其最低的k线未必有最高的成交量</li>
<li>SC的低点定义了TR的支撑线</li>
</ul></li>
<li><p>自动反弹AR</p>

<ul>
<li>供应的耗尽产生了从SC低点的初始反弹，随后由空头回补来继续推高价格</li>
<li>AR的高点定义了TR的阻力线</li>
</ul></li>
<li><p>二次测试ST    </p>

<ul>
<li>ST可以是SC和AR的一个局部事件（可以理解成AR中的一个ST，还会反弹跟高，只是一个中产休息）</li>
<li>ST可以做为一个更重要的确认</li>
<li>ST可以是一个小型的TR,整个小型TR作为一个测试行为</li>
<li>B中的一个产生更低的点的ST,可以理解为一个SOW,它指示出吸筹需要进行更多的测试，或者进行更久的盘整。（也就是这个ST也是需要被测试的）<br/></li>
</ul></li>
<li><p>上冲回落型的行为UA</p>

<ul>
<li>UA为了与派发中的UT进行区分</li>
<li>价格短暂的离开交易区间的阻力，又快速地回到阻力之下，意味着向上的突破失败，也意味着供应的出现</li>
</ul></li>
</ul>

<h3 id="toc_3">2.2 C段与D段</h3>

<ul>
<li><p>C和D的意图</p>

<ul>
<li>C：对TR支撑的最后测试（我们一般交易C段）</li>
<li>D：TR中的上涨，展现摆脱阻力的能力，并测试阻力已经转换成支撑</li>
</ul></li>
<li><p>威科夫原理</p>

<ul>
<li>C:Spring,TSO,LPS</li>
<li>D:SOS,LPS,JOC,BU</li>
</ul></li>
<li><p>Spring</p>

<ul>
<li>测试[A]与[B]的低点</li>
<li>可能成功，也可能失败</li>
<li>三种类型 Spring1,Spring2,Spring3</li>
<li>Spring与Spring的测试，等同于一个LPS</li>
</ul></li>
<li><p>终极震仓TSO</p>

<ul>
<li>宽价差和高成量的陡峭下跌</li>
<li>大幅打破TR支撑</li>
<li>快速的修复并回到TR支撑之上（必须）</li>
<li>在交易前需要测试</li>
</ul></li>
<li><p>强势信号SOS</p>

<ul>
<li>通常情况下，价格以宽价差和增加的成交量运动到TR的高位，甚至TR的阻力之上，指示出潜在的需求的增加</li>
<li>它可以是跳过小溪的第N次尝试，但却是最成功的一次</li>
<li>产生HH,HL(更高的高点，更高的低点)</li>
<li>次要的SOS可以发生在[B]中，主要SOS则发生在[D]中</li>
</ul></li>
<li><p>最后的支撑点LPS</p>

<ul>
<li>形成HL</li>
<li>低的成交量，窄的价差，或者减少的成家量和缩窄的价差</li>
<li>价格无法走的更低，并且之后不会在回到这个点，LPS本身可以被认为是一个强势信号</li>
<li>D中可以有多个LPS</li>
</ul></li>
<li><p>回测小溪BU</p>

<ul>
<li>上涨趋势之前，最后的较大回落</li>
<li>价格无法回到原有阻力之下，或者只能暂时地回到原阻力之下</li>
<li>回落幅度小于之前反弹的1/2最佳（即JOC那段的一半以上）</li>
</ul></li>
</ul>

<h2 id="toc_4">3. JOC</h2>

<h3 id="toc_5">注意点</h3>

<ul>
<li>展现突破阻力的能力</li>
<li>阻力区是一个区间，并且有厚度，是TR的最高点与次高点之间的区域</li>
<li>需要<strong>突破TR的最高点</strong>（一定要过最高点，才是完全突破了）</li>
<li>若果不是在突破最高点，交易的胜率很低 </li>
</ul>

<h3 id="toc_6">突破有效性</h3>

<ul>
<li><p>传统的判断方法</p>

<ul>
<li>Margin 突破幅度1-3%以上（依赖于品种）</li>
<li>Close 收盘价在阻力区之上</li>
<li>Time 两根K线在阻力区上</li>
<li>Volume 最好适当放量</li>
<li>Mixed Method 混合以上方法</li>
</ul></li>
<li><p>突破可以被预测吗</p>

<ul>
<li><p>不要买突破的原因分析？<br/>
如果是假突破，<strong>胜率</strong>就会降低<br/>
如果有回测，<strong>盈亏比</strong>会降低，而且回测较大时，会头寸很容易被打掉</p></li>
<li><p>买LPS还是买BU的比较 ？<br/>
LPS:胜率低，盈亏较高<br/>
BU:高胜率，盈亏比较低</p></li>
</ul></li>
</ul>

<h2 id="toc_7">4. Spring</h2>

<p>一个<strong>潜在spring</strong>是对一个支撑水平的刺穿。即向下突破失败。</p>

<ul>
<li><p>为什么用&quot;潜在&quot;?</p>

<ul>
<li><p>支撑水平的重要程度不同<br/>
意思是要有足够的cause。spring通过向下突破失败去测试水平支撑</p></li>
<li><p>刺穿的行为<br/>
价差，成交量</p></li>
</ul></li>
<li><p>Spring分类</p>

<ul>
<li><p>1类<br/><br/>
不是真正的Spring,是SOW</p></li>
<li><p>2类<br/><br/>
稍微较高的成交量</p></li>
<li><p>3类<br/><br/>
低成交量</p></li>
<li><p>后续变化<br/><br/>
2--&gt;3,2类转到3类，就是对2类的测试，是很好的交易时机<br/><br/>
2--&gt;1,2类有可能会转换成1，特别是在下跌趋势中  </p></li>
<li><p>Spring的质量</p></li>
<li><p>对支撑水平的刺穿深度（刺穿比较浅，收回比较快）</p></li>
<li><p>向潜在spring位置运动时，和进入spring位置时的价差（价差小）</p></li>
<li><p>向潜在spring位置运动时，和进入spring位置时的成交量（成交量小）</p></li>
</ul>

<blockquote>
<ol>
<li>成交量合适标准：前期横盘区的平均成交量的1/2,前期横盘区的平均价差1/2</li>
<li>Spring也可以是一个区域，并不完全是一个带下影的k线。</li>
</ol>
</blockquote></li>
</ul>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_1.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%89%8D%E8%A8%80.html"><strong>前言&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E4%B8%AA%E4%BA%BA%E7%B3%BB%E7%BB%9F.html"><strong>个人系统&nbsp;(10)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0.html">投资笔记&nbsp;(9)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.html"><strong>软件工程&nbsp;(49)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E7%AE%97%E6%B3%95.html">算法&nbsp;(8)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.html">网络协议&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.html">iOS基础概念&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E6%BA%90%E5%88%86%E6%9E%90.html">iOS开源分析&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html">iOS性能优化&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%B7%A5%E5%85%B7%E6%B7%B1%E5%85%A5.html">iOS工具深入&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="shell%E8%84%9A%E6%9C%AC.html">shell脚本&nbsp;(9)</a>&nbsp;&nbsp;
	        
	        	<a href="C%E8%AF%AD%E8%A8%80%E6%8D%A1%E6%BC%8F.html">C语言捡漏&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Git%E5%B7%A5%E5%85%B7.html">Git工具&nbsp;(3)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html">iOS架构设计&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Swift.html">Swift&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式&nbsp;(4)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E6%8A%80%E6%9C%AF.html"><strong>音视频技术&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15512048926912.html">设计模式系列（四）-- 行为型</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15512048797799.html">设计模式系列（三）-- 结构型</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15512048653711.html">设计模式系列（二）--创建型设计模式</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15512048416439.html">设计模式系列（一）设计模式概要</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15512046578708.html">Swift梳理</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>
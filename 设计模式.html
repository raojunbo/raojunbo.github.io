
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  设计模式 - 北哥传奇
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="北哥传奇" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">北哥传奇</a></h1>
  
    <h2></h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:raojunbo.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15512048926912.html">设计模式系列（四）-- 行为型</a></h1>
			<p class="meta"><time datetime="2019-02-27T02:14:52+08:00" 
			pubdate data-updated="true">2019/2/27</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>具体的实现Demo请进入<a href="https://github.com/raojunbo/DesignPatterns.git">DesignPatterns iOS工程实现</a>查看</p>

<h2 id="toc_0">13. 责任链模式</h2>

<p>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些<br/>
对象连接成一条链，并且沿着者条链传递请求，直到有对象处理它为止。<br/>
<strong>iOS里的事件传递。就是一种责任链模式</strong>。<br/>
使用场景<br/>
有多个对象可以处理一个请求，具体哪个对象处理该请求由运行时自动确定。<br/>
在不确定指定接收者的情况写，向多个对象中的一个提交一个请求。</p>

<h2 id="toc_1">14：命令模式(很重要)</h2>

<p>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。<br/>
使用场景<br/>
需要对<strong>行为进行记录</strong>，<strong>撤销</strong>或者重做，事物等的处理时。凡是有命令的地方，都可以使用命令模式。命令模式实现了很容易对命令的扩展（即对扩展开放），添加一个命令就可以了，同过这些命令取修改接受者的状态，其实我们直接执行函数就可以修改接受者的状态，当我们需要添加一些行为的记录，撤销的等行为，为了将行为的<strong>实现者receiver</strong>与行为的请求者(既可以是receiver也可以是其他对象)实现松耦合。</p>

<h2 id="toc_2">15：解释器模式</h2>

<h2 id="toc_3">16：迭代器模式</h2>

<p>提供一种按顺序访问一个聚合对象中的各个元素。而又无需暴露该对象的内部表示。<br/>
迭代器的关键代码是实现hasNext,next。<br/>
迭代器简化并且统一了对于集合类型的访问方法。在新添加的集合类型里，无需修改原有代码，只需要实现针对这个心添加的集合的迭代器就可以了。所以对扩展时开放的。</p>

<h2 id="toc_4">17：中介者模式</h2>

<p>中介者模式和我们日常生活中的中介者其实是一样的。房产中介。解决了买家与卖家之间错综复杂的关系。实现了。买家与中介联系，卖家与中介联系,当然这里协调的对象也可以是相同类型的比如都是&quot;买家&quot;,我们把买家与卖家统一称为“同事”（这类在初看文章的时候不理解为什么都是”同事“，其是为了方便描述罢了。在实际的开发中，那你想协调哪两种或者多种对象之间的交互都是可以的）。在对象的世界里面，也是如此。<br/>
实际的例子<br/><br/>
MVC里的模式，c就是中介者，m,v都是同事。c需要协调m与v的交互。那么从这里也可以看出。设计不当的时候很容易将c搞的比较复杂。<br/>
代码里的例子<br/>
 同事之间有一定的关系。同事A修改的分值，同事B的分值同样会修改。同事C的值统一会修改。<br/>
那么就有个问题，我同事A修改了值，我还要通过A取修改B的值，B的值修改了，B还要去修改C的值。这样就是对象间非常复杂的操作关系。<br/>
引入中介这后，这个几个对象之间的关系就变成只有中介者之间交互。这样关系就轻松多了。</p>

<h2 id="toc_5">18：备忘录模式</h2>

<p>保存一个对象的某个状态，以便在适当的时候恢复对象。<br/>
在不破话封装的前提下，捕获一个对象的内部状态，幷在该对象之外保存这个状态，这样可以<br/>
在以后将恢复到原先保存的状态。<br/>
实现代码的核心是搞一个备忘录的类。要保存状态的类可以实现协议方法，取出当前需要保存的<br/>
信息。和将保存的信息恢复为类的过程。整个是在需要备忘得对象实现的。<br/>
所以，备忘录其实，就时搞一个类专门实现“存”与&quot;取&quot;一个对象的状态，以备忘。</p>

<h2 id="toc_6">19：观察者模式</h2>

<p>当一个对象的状态发生改变的时候，所有的依赖对象都将得到通知。<br/>
解决一对多的情况。<br/>
观察者模式，在iOS里到处都有。通知中心，Kvo,等.</p>

<h2 id="toc_7">20：状态模式(很重要,实际的开始中很常见)</h2>

<p>对象的行为依赖于他的状态，并且可以根据它的状态的改变而改变相关的行为。<br/>
使用场景<br/>
当代码中包含有大量于状态有关的行为时。</p>

<h2 id="toc_8">21：策略模式</h2>

<p>策略模式同状态模式一样，不同的是将策略进行隔离。当有新的策略时，只需要扩展新的策略就行了。</p>

<h2 id="toc_9">22：模板方法模式</h2>

<h2 id="toc_10">23：访问者模式</h2>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15512048797799.html">设计模式系列（三）-- 结构型</a></h1>
			<p class="meta"><time datetime="2019-02-27T02:14:39+08:00" 
			pubdate data-updated="true">2019/2/27</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>具体的实现Demo请进入<a href="https://github.com/raojunbo/DesignPatterns.git">DesignPatterns iOS工程实现</a>查看</p>

<h2 id="toc_0">6. 适配器模式</h2>

<p>适配器模式将某个类的接口转换成客户端期望的另一个接口表示。目的是消除由于接口不匹配所造成的类的兼容性问题。分为3类，类适配器，对象的适配器</p>

<ol>
<li><p>类适配器<br/>
所谓的类适配器，指的是适配器Adapter<strong>继承</strong>我们的被适配者Adaptee，并实现目标接口Target。</p></li>
<li><p>对象适配器<br/>
所谓的对象适配器，就是适配器实现我们的接口，但是并不继承需要被适配的类。而是通过在构造函数中将需要被适配的类传递进来从而进行适配(也就是组合的形式)。</p></li>
</ol>

<p>它们的特点(至于特点，可以从它们的实现方法取考虑)<br/>
类适配器只能适配一个类，而对象适配器可以将不同的待适配者适配到统一目标。<br/>
而类适配器由于是继承，可以置换待适配对象的一些方法。</p>

<h2 id="toc_1">7. 外观模式</h2>

<p>外观模式让子系统更加易用，使用端不需要了解子系统的内部的实现。<br/>
也不需要跟众多子系统的内部的模块进行交互，只需要跟门面交互就可以了。外观角色好比一道屏障，对客户端屏蔽了子系统的具体实现。</p>

<h2 id="toc_2">8. 桥接模式</h2>

<p>桥接模式的场景：<br/>
类似于绘制形状，有多个形状，每个形状的颜色还不一样。为每种形状都提供各种颜色的版本，会造成n*n个类。</p>

<p>这是可以采用桥接模式，将<strong>继承关系转换成关联</strong>关系，为每种形状都提供各种颜色的版本。<br/>
桥接模式的本质是将继承关系转换成关联的关系。从而降低了类与类之间的耦合度，减少了系统中的类的数量，也减少了代码量。</p>

<h2 id="toc_3">9. 装饰</h2>

<p>有这样一个场景，购买咖啡时，可以要求在其中加入各种调料。例如<br/>
豆浆，摩卡，蒸奶，有时添加，有时不添加。这样就会导致类的爆炸，并且无法满足混合添加,多次添加的的情况。<br/>
关键的实现装饰类的实现</p>

<p>装饰类的设计，装饰类既有主类的属性，本类也是主类类型。这样可以递归的方式来获得最总被装饰了的对象。</p>

<h2 id="toc_4">10. 代理</h2>

<p>代理不说了，开始做iOS时就是代理模式。</p>

<h2 id="toc_5">11. 享元</h2>

<p>享元就是共享对象。既可以内存缓存对象，也可复用对象（通过一个唯一的标识）。</p>

<h2 id="toc_6">12. 组合模式</h2>

<p>我的理解，组合的设计模式在这里有两层含义。<br/>
一层含义：对象包含对象的问题，通过组合的方式（在对象内部引用对象）来进行布局。<br/>
二层含义：引申到树形结构的对象包含对象。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15512048653711.html">设计模式系列（二）--创建型设计模式</a></h1>
			<p class="meta"><time datetime="2019-02-27T02:14:25+08:00" 
			pubdate data-updated="true">2019/2/27</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>接下来将进入设计模式里的创建型设计模式。这里将对设计模式的使用场景与优劣，以及UML图做描述。<br/>
具体的实现Demo请进入<a href="https://github.com/raojunbo/DesignPatterns.git">DesignPatterns iOS工程实现</a>查看</p>

<h2 id="toc_0">0. 简单工厂（if type）</h2>

<p>（通过传类型进行区分，对修改是开放的，所有不好）<br/>
简单工厂就是一个工厂，将类型传进去，在一个类里面生成不同的类型。<br/>
弊端：这个工厂会包括多个需要生产的产品的引用。而且对于修改是开放的，因为需要修改类里面的内容。对于扩展也是需要在同一个类里面做修改。</p>

<h2 id="toc_1">1. 工厂方法（一个产品线）</h2>

<p>使用场景：<br/>
当需要创建多种分Type的对象时，特别是针对多种类型有共同的行为特征时。或者写出简单工厂时，思考是否可以用工厂方法。</p>

<p>好处：<br/>
工厂方法遵循开闭原则就是”对扩展开放，对修改关闭”，再说白点就是实现工厂方法以后要进行扩展时不需要修改原有代码（你看简单工厂里添加类型时时不是还要修改if语句），只需要增加一个<strong>工厂实现类</strong>和<strong>产品实现类</strong>就可以。</p>

<p>实现：<br/>
产品基类（协议），工厂基类(协议)。产品实现，工厂实现。客户端直接使用工厂生产相应的产品就可以了。</p>

<p>费曼<strong>工厂方法会针对每个产品都有一个工厂实现类</strong>。工厂实现类有一个相应工厂的一个实现，这个实现是生产产品的实现。我们可以将工厂方法理解成一个产品线。</p>

<h2 id="toc_2">2. 抽象工厂（多个产品线及真正的工厂）</h2>

<p>使用场景<br/>
1.通过对象组合创建抽象产品<br/><br/>
2.创建多个系列产品<br/>
3.必须修改父类的接口才能支持新的产品</p>

<p>费曼  <strong>所谓的抽象工厂，就是将工厂方法的产品线扩大到多个产品线</strong> 我们可以将抽象工厂理解成多条产品线（真正的工厂）,每一个工厂有其特殊的标识。</p>

<p>突然想到一个例子<br/>
”北京杂酱面“ 与 “重庆杂酱面”都是杂酱面，都是配料都是面条，汤，酱，但北京面馆（一个工厂），是北京面条，北京汤，北京酱，重庆面馆（一个工厂）是重庆面条，重庆汤，重庆酱，这个工厂是一个产品线。</p>

<h2 id="toc_3">3. 单例模式(整个应用程序只用一个对象)</h2>

<p>使用场景<br/>
在一个应用程序中，当需要在多个地方共享数据时</p>

<p>注意点<br/>
注意多线程的使用下的情况。</p>

<p>在实际的使用中，单例模式也不能滥用。举个例子，单例有个isLogin，我判定isLogin为true进入一个操作，其他线程将isLogin改成false，那么在这个单例里执行的操作都将有问题。<br/>
因为数据被其他线程改变了。在实际的开发中，这种情况会是一个大坑。</p>

<h2 id="toc_4">4. 构建者(子部分算法的变化无常，当构成这个对象组成相对固定)</h2>

<p>构建者模式使用多个简单的对象一步一步构建一个复杂的对象。<br/>
<strong>主要解决的问题，有时候面临着&quot;一个复杂的对象&quot;的创建工作，通常其子对象部分有着剧烈的变换，需要将他们组合在一起</strong>。</p>

<p>我的理解是，当创建一个对象，这个对象需要很多组合的对象（且这些组合的对象有一定固定算法，我需要将这些对象随意的组合成我需要的对象）时，用构建者模式。（区别与抽象工厂，抽象工厂创建后不是随意的组合，是工厂创建后就只能生产固定的产品了，抽象工厂的变换在外部，而构建者的变换在内部，哈哈，就是这个意思）<br/>
例如<br/>
构造电脑，电脑的组成由CPU,显示器，主板，这是相对固定的。但子部分，CPU有各种实现的算法。所以这种情况使用构建者最好。</p>

<h2 id="toc_5">5. 原型模式</h2>

<p>原型模式<br/>
原型遵循copy或者clone的协议。执行copy或者clone就是按照原型创建一个对象。在iOS里理解成copy就行了。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15512048416439.html">设计模式系列（一）设计模式概要</a></h1>
			<p class="meta"><time datetime="2019-02-27T02:14:01+08:00" 
			pubdate data-updated="true">2019/2/27</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在这里给大家推荐一本设计模式入门的书《HeadFirst 设计模式》，这是我真正理解设计模式的开始。当然对于设计模式的理解，需要一定的开发经验才能真正理解的。<br/>
<img src="https://github.com/raojunbo/picres/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-02%2012.50.34.png?raw=true" alt="image"/><br/>
本篇文章不是对设计模式的全解。而是我自己在iOS的实践中对设计模式的理解的一个一个梳理。我在<a href="https://github.com/raojunbo/DesignPatterns.git">DesignPatterns iOS工程实现</a>里写出了相关的<a href="https://github.com/raojunbo/DesignPatterns.git">Demo</a></p>

<p>学习方法：抽象—》具体—》应用—》引申。重点在与理解设计模式的几大原则在设计模式里的体现。当你理解了几大原则在设计模式里的体现，也就理解了设计的精髓所在。在自己写出相关Demo后，然后自己默写出相关设计模式的UML图，分析每种设计模式的优劣是为解决什么问题而诞生。那么那你就真正理解了设计模式。</p>

<h2 id="toc_0">设计模式的六大原则</h2>

<ol>
<li><p>开闭原则（面向对向设计的首要目标:<strong>对扩展开放，对修改关闭</strong>）<br/>
对扩展开放，对修改关闭，也就是在进行扩展时，不要对先前的代码修改（因为如果对先前的代码进行修改的化，需要重新测试）。对扩展开放最好直接创建一个新类，其他的东西都不要更改。可以采用抽象的方式，将对象抽象出来，形成对这个&quot;抽象化&quot;处理。</p></li>
<li><p>里氏替换原则（<strong>子类替换基类业务不受影响</strong>）<br/>
在软件中将一个基类对象替换成它的子类对象，程序不将不会出现任何差错。其实这是开闭原则的一个实现。也就是在程序中尽量使用基类类型来对对象进行定义，而运行时在确定其子类类型。这样有一种<strong>面向基类，面向协议编程</strong>，这样在有扩展进来时，更改的代码就会很少。</p></li>
<li><p>依赖倒置原则(<strong>面向协议编程</strong>)<br/>
名字取的很高大上。实际就一句话，实现依赖抽象，抽象不依赖实现。也就是面向协议编程，不针对实现编程。</p></li>
<li><p>接口隔离原则(<strong>接口分离</strong>)<br/>
使用多个专门的接口，而不使用单一的总接口。每个接口<br/>
应该承担一种相对独立的角色，将不同功能类型的接口进行分离</p></li>
<li><p>迪米特法则（<strong>减少对象之间交互</strong>）<br/>
应该减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应该发生任何直接的作用。</p></li>
<li><p>合成复用原则（<strong>多用组合少用继承</strong>）<br/>
尽量使用合成与聚合，而不是使用继承。<br/>
这条在实际的开发中，的确很有感触。继承用的不好会导致维护的困难。</p></li>
</ol>

<h2 id="toc_1">设计模式分类</h2>

<p>创建型设计模式<br/>
结构型设计模式<br/>
行为型设计模式</p>

<h3 id="toc_2">一：创建型（5种）</h3>

<p>1:单例模式<br/>
2:工厂方法(生成单一产品)<br/>
3:抽象工厂（生产系列产品）<br/>
4:建造模式（生产比较复杂的具有统一生产流程的产品，将生产流程固话）<br/>
5:原型设计模式(clone的实现)</p>

<h3 id="toc_3">二：结构型（7种）</h3>

<p>6:适配器模式（将一个对象适配成需要的接口）<br/>
7:桥接模式<br/>
8:组合模式（类似于iOS里的view，对每一个组件具有相同的操作方法）<br/>
9:外观模式（子系统）<br/>
10:享元模式（聚合使用）<br/>
11:代理模式<br/>
12:装饰模式</p>

<h3 id="toc_4">三：行为型（11种）</h3>

<p>13:责任链模式<br/>
14:命令模式<br/>
15:解释器模式（暂时不太明白）<br/>
16:迭代器模式<br/>
17:中介者模式<br/>
18:备忘录模式<br/>
19:观察者模式<br/>
20:状态模式<br/>
21:策略模式<br/>
22:模板方法模式<br/>
23:访问者模式(暂时不太明白)</p>

<p>其中，命令模式，状态模式，策略模式，都是同的思想，将命令封装，将状态封装，将策略封装。</p>


		</div>

		

	</article>
  
	<div class="pagination">
	
<a href="archives.html">Blog Archives</a>
	 
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%89%8D%E8%A8%80.html"><strong>前言&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E4%B8%AA%E4%BA%BA%E7%B3%BB%E7%BB%9F.html"><strong>个人系统&nbsp;(10)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0.html">投资笔记&nbsp;(9)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.html"><strong>软件工程&nbsp;(49)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E7%AE%97%E6%B3%95.html">算法&nbsp;(8)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.html">网络协议&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.html">iOS基础概念&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E6%BA%90%E5%88%86%E6%9E%90.html">iOS开源分析&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html">iOS性能优化&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%B7%A5%E5%85%B7%E6%B7%B1%E5%85%A5.html">iOS工具深入&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="shell%E8%84%9A%E6%9C%AC.html">shell脚本&nbsp;(9)</a>&nbsp;&nbsp;
	        
	        	<a href="C%E8%AF%AD%E8%A8%80%E6%8D%A1%E6%BC%8F.html">C语言捡漏&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Git%E5%B7%A5%E5%85%B7.html">Git工具&nbsp;(3)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html">iOS架构设计&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Swift.html">Swift&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式&nbsp;(4)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E6%8A%80%E6%9C%AF.html"><strong>音视频技术&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15512048926912.html">设计模式系列（四）-- 行为型</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15512048797799.html">设计模式系列（三）-- 结构型</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15512048653711.html">设计模式系列（二）--创建型设计模式</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15512048416439.html">设计模式系列（一）设计模式概要</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15512046578708.html">Swift梳理</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>
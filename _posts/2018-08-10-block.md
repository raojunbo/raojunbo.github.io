---
layout: post
title: Block
date: 2018-08-10 23:34:15.000000000 +09:00
tags: iOS技术
---
#Block

##本文要思考的问题
本文将会解决的如下疑问
1. block内存如何管理
2. 为什么会造成循环引用
3. 延时释放的原理
4. block的实现原理的本质推演

##Block概念
一句话：”一个能捕获局部变量，且保存了可执行代码的一个对象“，对象类型有isa指向，__NSGlobalBlock__,__NSMallocBlock__，__NSStckBlock__。
##Block内存管理
- 无论当前环境是ARC还是MRC,只要blockm没有访问外部变量，block始终在Global区。
- MRC 
    - block 如若果访问外部变量，block在栈里
    - 只要使用copy,才能放到堆里
- ARC 
    - block如果访问外部变量，block在堆里
    - block可以使用strong,copy,并且block是同一个对象

##Block循环引用
- 费曼输出：**self引用block,block引用self**。
如果对此理解的不是很清楚，而只是一味按照其他人说的避免循环引用的方式。就没有抓住本质，也就不能创造性的解决问题。
self引用block,就是self持有这个block,block引用self，是因为block代码里使用到了self，或者self.property,_ivr,block默认会对这个self,实现强引用。
解决的办法是不让block对self进行强引用。也就是block不对self进行一次release的权限。

- 延时释放(重点，这个问题我想了好久，是如何办到的)
但有时会遇到，需要在block执行时，self一定要存在。即需求是延时self的释放。尽管有时，self释放后，执行block时，不会对逻辑造成影响（对nil发起的操作不做任何反应）。这时。我们需要在在block里对self的一次强引用。那有人会问，在block外面进行强引用，与在block里面进行强引用，不都是强引用吗？_为啥，在外面强引用会造成循环引用，在block里面做强引用不会造成循环引用呢？__
因为Block的实现原理导致。请看Block的实现原理如下

##Block的实现原理
- 费曼输出：Block在内存里实际是一个对象，而在Object-C里，对象实际是一个结构体。
**Block结构体里保存了“实现”，“描述”，“捕获的变量”。实现里保存了isa,funcPtr,而isa是这个对象类型，funcPtr就是函数指针，指向那个可执行的一个函数。函数的数据来源就是这个Block里捕获的变量**

代码如下
oc代码

```
test1() {
    int a = 10;
    void (^block)()= ^{
        NSLogt("%d",a);
    }
    a = 20;
    block();
}

int main(int argc,const char *argv[]){    
    test1();
    return 0;
}

```

编译成c++代码

```
struct __test1_block_impl_0 {
        struct __block_imple impl;
        struct__test1_block_desc_0 *Desc_0;
        _int a;
        __test1_block_impl_0(void *fp,struct_test1_block_desc_0*Desc,int _a,int flag =0):a(_a) {
            impl.isa = &_NSConcreteStackBlock;
            impl.Flags = flags;
            impl.FuncPtr = fp;
            Desc = desc;
        }
    };
    
static void __test1_block_func_0(struct __test1_block_imp_0 *__cself) {
    int a = __cself->a;
    NSLog(a);
}

void test1 () {
    int a  = 10;
    //block的定义转换成c++的定义，这是block的初始化（c++结构体的初始化）,生成block。
    void(*block)() = (void (*)())&__test1_block_imp_0((void *))__test1_block_func_0,&__test1_block__desc_0_DATA,a);
    a = 20;
     //执行block   
    ((void (*)(__block_impl *))((__block_imp *)block)->FuncPtr)((_block_impl *)block);
}
int main(itn argc,const char *argv[]){
    test1();
    return 0;
}
```

简单推演
1.  _int a; 是捕获的变量
2. __test1_block_func_0 ;是可执行的代码
3.执行block时，实际是执行声明的block里的FuncPtr,并将自己当做参数传了进去。

我们回到延时释放的解释：从这里就能解释为什么从外面强引用会造成循环引用，因为block的结构体里实现了对self的捕获。并强引用了。从里面实现强引用，为什么不造成循环引用，是因为，从里面是在__test1_block_func_0函数里了。是一个局部变量了。block执行完时，自然会对这个局部变量实行释放。哈哈。终于揭开了疑惑。！！！

对于__block变量的捕获原理，其实本质是一样的。只不过，是在捕获int a是传值进去。而__block变量是传地址进去。（特别说明：__block,static的变量，全局变量都是传指针）


##block实践感悟
block是强大的。可以做保存代码，可以当返回值，可以当参数，总之，将其当一般对象使用，外加他能保存代码并执行，那就简直强大无比了。Masory里将block做返回值实现链式编程，就是一个很好的实践。


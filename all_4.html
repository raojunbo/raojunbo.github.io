
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  北哥传奇
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="北哥传奇" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">北哥传奇</a></h1>
  
    <h2></h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:raojunbo.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15381303838316.html">OFFER 第4章 解决问题的思路与方法</a></h1>
			<p class="meta"><time datetime="2018-09-28T18:26:23+08:00" 
			pubdate data-updated="true">2018/9/28</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">27.二叉树的镜像</h3>

<p>请完成一个函数，输入一颗二叉树，该函数输出它的镜像。</p>

<p>思路<br/>
遍历时，交换左右子树。然后递归的去交换子树就可以了。直到root为null</p>

<h3 id="toc_1">28.对称的二叉树</h3>

<p>请实现一个函数，用来判断一颗二叉树是不是对称的。如果一颗二叉树和他的镜像一样，那么它是对称的。(LeetCode 101. Symmetric Tree)</p>

<p>思路<br/>
用前序遍历时时“根左右”，通过观察与“根右左”的在对称的二叉树序列是一样的。哈哈。在定义三种遍历方式时，都是针对于根的。没有定义左于右的顺序。<br/>
不过这个递归表达是由点难想到。</p>

<h3 id="toc_2">29. 顺时针打印矩阵</h3>

<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。例如输入如下矩阵<br/>
<img src="media/15381303838316/Xnip2018-10-01_22-21-50.png" alt="Xnip2018-10-01_22-21-50"/></p>

<p>思路<br/>
可以将矩阵分圈打印。那么难点在于边界条件的判定。</p>

<h3 id="toc_3">30. 包含min函数的栈</h3>

<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中调用min,push及pop的时间复杂度O(1)</p>

<p>思路<br/>
入栈比较，是最小值入栈，不是最小值，将栈重新入栈。这样每出栈时，辅助栈也会出栈。</p>

<h3 id="toc_4">31. 栈的压入与弹出序列（这个思路是清晰的，但实现起来有点麻烦未实现完）</h3>

<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列{1，2，3，4，5}是某栈的压栈序列，序列{4，5，3，2，1}是该压栈序列对应的一个弹出序列，但{4，3，5，1，2}就不可能是该压栈序列的弹出序列。</p>

<p>思考<br/>
可以模拟入栈与出栈的过程，待输入序列是1,2,3,4,5,待输出序列是4,5,3,2,1,则，对入栈一直入栈，当发现即将要入栈的元素与输出序列的元素相等时，入栈并出栈这个元素。头部元素与输出序列的下一个比较，相等则出栈。不相等就将下一元素入栈。发现头部元素与待书序序列不等，且与即将输入的元素不等时，即不是其输出序列。</p>

<h3 id="toc_5">32. 从上到下打印二叉树(不换行)</h3>

<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。例如，输入图4.6中的二叉树，则依次打印出8,6,10,5,7,9,11。</p>

<p>思路（我的）<br/>
就是二叉树的层序遍历。<br/>
层序遍历的实现，根入队列，出队列时将其左，右节点入队列。知道最终队列为空。</p>

<h4 id="toc_6">32.1 从上到下打印二叉树(换行)</h4>

<p>从上到下打印二叉树,同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>

<p>思路<br/>
与上面的相同，只是需要找到如何去标记换行的问题。<br/>
换行的问题，可以记录入已经在本行打印了的，记录下一行要打印的个数。</p>

<h4 id="toc_7">32.2 之字形打印二叉树</h4>

<p>实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行在按照从左到右的顺序打印，其他行以此类推。</p>

<p>思路（哈哈，这个是我自己想出来的哟）</p>

<p>和上面的思路类似。只是为了保证打印时的顺序按照所需要的。搞两个栈，一个正序入栈，一个逆序入栈。相互交换着输出。</p>

<h3 id="toc_8">33. 二叉搜索树的后序遍历序列</h3>

<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回true,否则返回false.假设输入的数组的任意两个数字都互不相同。例如，输入数组{5，7，6，9，11，10，8}，则返回true,因为这个整数序列是图4.9二叉搜索树的后序遍历结果。如果输入的数组时{7,4,6,5},则由于没有哪棵二叉搜索树的后序遍历结果是这个序列，因此返回fasle;</p>

<p>思路（我自己分析出来的）<br/>
思考过程，刚开始的确没有思路，从二叉搜索树的特征来看，每个节点的左边小于根节点，每个节点的右边大于根节点。所以可以找到整个序列的根节点。然后找出左子树与右子树。在分别对左右子树看其是否左子树元素都小于根，右子树都大于根。</p>

<p>测试用例<br/>
完全二叉树，只有左子树，只有右子树，只有一个节点，空树等。</p>

<h3 id="toc_9">34. 二叉树中和为某一值的路径</h3>

<p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>

<p>思路<br/>
要寻找某一条路径。明显的找到根节点然后尝试添加为和。知道根节点。在外部维持一个栈，访问元素时，添加栈，退出递归时将元素移除栈。在刚好和的值与要找的相等时，刚好栈里就是路径。</p>

<p>测试用例<br/>
如果有多个路径能支持的情况<br/>
在中间值，就已经找到了<br/>
在叶子节点才找到</p>

<h3 id="toc_10">35.复杂链表的复制（这题要有发散思维）</h3>

<p>请实现函数复制复杂链表。在复杂链表中，每个节点除了有一个m_pNext指针指向下一个节点，还有一个m_pSibling指针指向链表中的任意节点或者null;</p>

<p>思路<br/>
我的思考，先将主要的链条连接起来。然后将次要链条连接。那么思考在次要链表的链接上实际可能的花废O(n2);</p>

<p>优化思路1<br/>
基于以上思路，o(n2)的花费主要是寻找其他节点位置上。可以用hasn表存储<N,N`>的对应关系。当原始是N时复制的链表是N`.<br/>
这样解决的办法是用空间换时间。</p>

<p>优化思路2(这种)<br/>
对于优化思路1的空间问题，我们要实现不用辅助空间的情况下实现O(n);<br/>
<img src="media/15379486241928/Xnip2018-09-27_15-58-18.png" alt="Xnip2018-09-27_15-58-18"/><br/>
<img src="media/15379486241928/Xnip2018-09-27_15-58-31.png" alt="Xnip2018-09-27_15-58-31"/></p>

<h3 id="toc_11">36. 二叉搜索树和双向链表</h3>

<p>输入一颗二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的节点，只能调整树中节点指针的方向。</p>

<p>思路<br/>
因为二叉的特性。根节点一定大于左子树的所有节点，根节点一定小于右子树的所有节点。要将其换成双向链表。首先弄成单向链表。将子树的右子树移动到根节点的右上。左子树移动到父节点的右下。递归进行。</p>

<h3 id="toc_12">37. 序列化二叉树</h3>

<p>请实现两个函数，分别用来序列化和反序列化二叉树</p>

<p>思考<br/>
二叉树的序列化，就是保证序列化后的唯一。要保证唯一。可以保存先序遍历，在保存中序遍历。这样可以恢复二叉树。</p>

<p>优化思路（这种思路较好，用特殊字符代表null，是我没想到的）<br/>
上面的过程需要将两个序列化都读取后才能进行恢复。我们可以根据前序遍历的顺序来序列化二叉树，因为前序遍历是从根节点开始的。在遍历二叉树碰到null指针时，这些null指针序列化为一个特殊的字符。</p>

<h3 id="toc_13">38.字符串的排列</h3>

<p>输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出字符a,b,c所能排列出来的所有字符串，abc,acb,bca,cab,cba;</p>

<p>思路（思想很重要）<br/>
通过上面的排列，可以将其分成以a开头的，以b开头的，以c开头的，然后分别后面的进行排列，重复这个过程。<br/>
即将问题转换成子问题。同过子问题的递归。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15380441185875.html">OFFER 第5章 优化时间效率与空间效率</a></h1>
			<p class="meta"><time datetime="2018-09-27T18:28:38+08:00" 
			pubdate data-updated="true">2018/9/27</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">39. 数组中出现次数超过一半的数字</h3>

<p>数组中有一个数字出现的次数超过数组长度的一半。请找出这个数字。例如，输入一个长度为9的数组{1，2，3，2，2，2，2，5，4，2}。由于数字2在数组中出现了5次。超过数组长度的一半。因此输出2；</p>

<h3 id="toc_1">40. 最小的k个数</h3>

<p>输入n个整数，找出其中最小的k个数，例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1，2，3，4；</p>

<h3 id="toc_2">41. 数据流中的中位数</h3>

<p>如何得到一个数据流中的中位数，如果从数据流中读取奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值。那么中位数就是所有数值排序之后中间两个数的平均值。</p>

<h3 id="toc_3">42. 连续子数组的最大和</h3>

<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或者连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n);</p>

<h3 id="toc_4">43. 1~n整数中1出现的次数</h3>

<p>输入一个整数n，求1~n这n个整数的十进制表示1出现的次数。例如输入12,1~12这些整数包含1的数字有1,10,11和12，1一共出现的次数为5次。</p>

<h3 id="toc_5">44. 数字序列中某一位的数字</h3>

<p>数字以012345678910111213141516的格式序列化到一个字符序列中。在这个序列中，第5位(从0开始计数)是5，第13位1，第19位时4等等。请写一个函数，求任意第n位对应的数字。</p>

<p>思考<br/>
一般的解决思路是不断累加数字，直到找到第几位。<br/>
我自己的优化思路，比如数字967，<code>(967-99)*3 + （99-9）*2+ 9*1</code></p>

<h3 id="toc_6">45. 把数组排成最小的数</h3>

<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接处的所有数字中最小的一个。例如输入数组{3,2,321},则打印出这3个数字能排成的最小数字321323；</p>

<p>思考<br/>
直接的做法是求全排列进行比较。<br/>
另一种做法是要将数字最小的放在其前面，在首字相同，又要比较第二个的大小。这样就可以联想到，通过自定义一种比较规则，然后通过nlog(n)的时间里。将其排序出来，那么这个规则的定义与证明就是一个数学问题。</p>

<h3 id="toc_7">46. 把数字翻译成字符串</h3>

<p>给定一个数字，我们按照如下规则把它翻译为字符串：0翻译成a,1翻译成b,25翻译成z,一个数字可能有多少个翻译。12258有5种不同的翻译，分别是bccfi,bwfi,bczi,mcfi,mzi,请编程实现以函数，用来计算一个数字有多少中不同的翻译方法。</p>

<p>思路<br/>
没想明白</p>

<h3 id="toc_8">47. 礼物的最大价值</h3>

<p>在一个m*n的棋盘的每一格都放右一个礼物，每个礼物都有一定的价值。你可以从棋盘的左上角开始拿格子里的礼物，并每次向左或者向下移动一格，直到到达棋盘的右下角。给定一个棋盘及其上面的礼物，请计算你最多能拿到多少价值的礼物？</p>

<p>思考<br/>
我当前的结果。如何由前面的结果得来。而分治法是由一些子问题，在综合成大问题。<br/>
动态规划有时是由向大。因为基于原有小的已经算出来的值，取计算大规模的值。<br/>
这里当前的最大值，从上，从左而来。我需要比较从上的最大值+当前值，与从左而来的值+当前值 两个比较。以求出当前的最大值。也就是利用以前的结果计算当前的结果。</p>

<h3 id="toc_9">48. 最长不含重复字符的子字符串</h3>

<p>从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含‘a&#39;~&#39;z&#39; 的字符。例如 在字符串’arabcacfr‘中，最长的不含重复字符的子字符串’acfr&#39;，长度为4;</p>

<p>思考<br/>
后面的依赖前面结果，很容易想到动态规划。<br/>
需要注意的是，动态规划的实现，可以考虑使用循环来实现。而不是使用递归。</p>

<h3 id="toc_10">49. 丑数(一点思路都没有)</h3>

<p>我们把只包含因子2，3，5的数叫做丑数。求按从小到大的顺序的第1500个丑数。例如6,8都是丑数，但14不是，因为它只包含因子7，</p>

<h3 id="toc_11">50.第一个只出现一次的字符</h3>

<p>字符串中第一个只出现一次的字符。在字符串中找出第一个只出现一次的字符。如输入abaccdeff，则只输出b；</p>

<p>思考<br/>
一种思路是从头开始然后遍历到最后，知道找到只有一次的字符。时间复杂度是O(N2)</p>

<p>另一种思路<br/>
遍历一次保存字符的次数。用hash表，以字符为key值，以出现的次数为值。最后再遍历一次hash表，就可以找出该首先出现只有一次的字符。时间复杂度是O(n)+O(n)，即最终是O(n)。</p>

<h3 id="toc_12">51. 数组中的逆序对</h3>

<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对，输入一个数组，求出这个数组中的逆序对的总数。例如在数组{7,5,6,4}中，一共存在5个逆序对，分别(7,6),(7,5),(7,4),(6,4)和（5，4）;</p>

<p>思路（这个题我没有比较清晰的思路）</p>

<h3 id="toc_13">52. 两个链表的第一个公共节点</h3>

<p>输入两个链表，找出它们的第一个公共节点。<br/>
<img src="media/15380441185875/Xnip2018-09-28_18-10-12.png" alt="Xnip2018-09-28_18-10-12"/></p>

<p>思路一<br/>
从一个链表开始遍历，比较第二个链表。知道找到相同值即可。时间复杂度时O(N2)</p>

<p>思路二<br/>
假如我们从后面往前面遍历就好了。这样找到最后的不同就可以了。<br/>
我们想到，用两个辅助的栈，每个链表加到各自的栈里，然后同时出栈就可以直到最后一个相同为止。时间复杂度是O(N),空间复杂度也是O(N)</p>

<p>思路三<br/>
遍历链表一，几下总数，遍历链表二，几下总数，用长的向前走动两个节点数之差。然后同时相前走动，直到相同为止。这种是最好的思路。</p>

<h3 id="toc_14">总结</h3>

<p>降低时间复杂度的方法是改用更高效的算法。比如用动态规划，用类似于快速排序的分区，将递归改为循环的实现（如果有重复的子问题）</p>

<p>第二种方法,用空间换时间，例如可以用hash表，</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15379486241928.html">OFFER 第3章 高质量的代码</a></h1>
			<p class="meta"><time datetime="2018-09-26T15:57:04+08:00" 
			pubdate data-updated="true">2018/9/26</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>3个方面确保代码的完整性<br/>
功能测试(基本功能)<br/>
边界测试(边界条件)<br/>
负面测试(错误输入)</p>

<h3 id="toc_0">16. 数的整数次方</h3>

<p>实现函数Power(double base,int exponent),求base的exponent次方。不得使用库函数。</p>

<p>思路<br/>
用循环不断相乘是一种方法。但很容易想到，如果数值很大的时候，就会出现溢出。不能满足需求。</p>

<p>周密性考察<br/>
考虑到大数问题(我们这里不考虑大数问题)<br/>
考虑到<strong>指数的负数问题</strong><br/>
考虑到<strong>指数为0</strong>的问题<br/>
关键的是大数问题，直接影响到我们的实现方式</p>

<p>优化思路（快速做乘方）<br/>
假如果我们的目标是求出一个数字的32次方。若果我们已经知道了它的16次方。那么只要在16次方的基础上在平方一次就可以了。而16次方是8次方的平方。这样就可以减少乘积的次数。</p>

<h3 id="toc_1">17. 打印从1到最大的n位数(如果用递归解决的话比较经典)</h3>

<p>输入数字n,按顺序打印出从1到最大的n位十进制数，比如输入3，则打印出1，2，3，一直到最大的3为数999；</p>

<p>思路(这个思路很传统)<br/>
模拟加法</p>

<p>思路二(哈哈，这个思路很精妙)<br/>
递归打印。当为们想到全排列的时候，可以采用递归的方式</p>

<h3 id="toc_2">18. 删除链表的节点</h3>

<p>在O(1)时间内删除链表节点。<br/>
给定单向链表的头指针和一个节点指针，定义在O（1）时间内删除该节点。</p>

<p>思考<br/>
要在O(1)时间内删除，普通做法是要找到所要删除节点的上一个节点，时间复杂度为O（n）。所以采取其他方法。</p>

<p>思路<br/>
可以将指定节点的后面节点的值赋值给当前节点。然后将后面节点的后面节点连接上当前节点。<br/>
有些特殊情况需要考虑。一是：当所要删除的是最后一个节点，则只能从最开始遍历。二是。所删除节点是倒数第二个节点。赋值后，直接将当前节点的next节点置位null;三是，指定的节点在原有链表中不存在的特殊处理。四是，链表本身是空</p>

<h4 id="toc_3">19. 正则表达式(未完成)</h4>

<p>请实现一个函数用来匹配包含“.&quot;和&quot;<em>&quot;的正则表达式。模式中的字符”.&quot;表示任意一个字符，而“</em>” 表示它前面的字符可以出现任意次（包含0次）。在本题中匹配是指字符串的所有字符匹配整个模式。例如字符串“aaa&quot;与模式&quot;a.a&quot;和&quot;ab<em>ac</em>a&quot;匹配，当与”aa.a&quot;和&quot;ab*a&quot;均不匹配。</p>

<p>思路<br/>
我的思路，遍历模式，一个以字符与需要匹配的字符相比较。遇到&#39;.&#39;,需要匹配的字符跳过一个，模式也要跳过一个。因为&#39;.&#39;表示任意一个字符。如果字符与需要匹配的不相同，有两种选择，若果模式后面有*。则可以将其和*忽略，相当于有0个这个字符。然后与后面的进行比较.</p>

<h3 id="toc_4">20.表示数值的字符串(未完成)</h3>

<p>请实现一个函数用来判定字符串是否表示数值。例如字符串&quot;+100&quot;,&quot;5e2&quot;,&quot;-123&quot;,&quot;3.1412&quot;,&quot;-1E-16&quot;都表示数值。</p>

<h3 id="toc_5">21.调整数组顺序使奇数位与偶数前面</h3>

<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分</p>

<p>思路<br/>
采用两个指针头尾，头尾同时判定，头为奇数++，尾为偶数++,头为偶数，直到尾为奇数然后交互, 这样在o(n)的时间复杂度</p>

<h3 id="toc_6">22.链表中倒数第K个节点</h3>

<p>输入一个链表，输出该链表中倒数第k个节点。（最后一个节点为1）</p>

<p>思路<br/>
一般思路，遍历以便链表，几下链表长度。然后将从头开始遍历。走n-k步就可以了<br/>
也可以用一个辅助栈，将说有元素入栈，完事后将其弹出k个最后一个就是</p>

<p>优化思路<br/>
可以采用两个指针，前一个指针走了k步后，后一个指针开始走。这只需要遍历一次就能找到倒数第k个节点</p>

<h3 id="toc_7">23. 链表中环的入口节点</h3>

<p>如果一个链表中包含环，如何找到环的入口节点？<br/>
<img src="media/15379486241928/Xnip2018-09-30_14-42-44.png" alt="Xnip2018-09-30_14-42-44"/></p>

<p>思路<br/>
链表的解决方案都有比较好的套路。<br/>
判定是否有环：搞两个指针一个走两步，一个走一步，有环的话，快指针会赶上慢指针。<br/>
找入口：如果是相遇，那么必然在环里，然后看环有多个元素。从相遇的那个节点开始，做遍历，必然会回到这，可以查看有多少个元素。加入为k个元素。还是用两个指针，p1,p2,p2向前走k个元素，然后p1与p2同时走。当相遇时，就是环的入口节点.</p>

<h3 id="toc_8">24. 反转链表</h3>

<p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>

<p>思路<br/>
定义新的头节点，取出就节点的后一个节点，放到新的节点的前面（即采用头插法）。在最后将头旧的头节点的next置为null;反回新的头节点就可以了。这里要特别注意节点信息的丢失</p>

<p>从上面的思路可以看出也能用递归实现<br/>
递归的头条件还是那些条件。终止条件其实也是一样的。</p>

<h3 id="toc_9">25. 合并两个排序的链表</h3>

<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点任然是递增排序的。<br/>
<img src="media/15379486241928/Xnip2018-09-30_17-27-57.png" alt="Xnip2018-09-30_17-27-57"/></p>

<p>思路<br/>
比较两个链表的头，以头小的为准。边遍历，边比较与链表2的头。p.next与链表2比较。P.next大则将链表2的节点连接到链表1，更新链表2的头。如果表1的p.next==null,则直接将表2的放在表1的后面<br/>
时间复杂度为o(m+n);</p>

<p>优化思路（用递归实现的思路要清晰一些）(思想很重要)<br/>
思路其实和上面的一样。只是从不同的角度去看。这里从递归的角度去看问题。在比较两个链表的头部后，将小的放入新的链表的后面。这样重复炒作。就是一个递归问题。</p>

<h3 id="toc_10">26. 树的子结构</h3>

<p>输入两棵二叉树A和B,判断B是不是A的子结构.<br/>
<img src="media/15379486241928/Xnip2018-09-30_18-41-21.png" alt="Xnip2018-09-30_18-41-21"/></p>

<p>思路<br/>
按照树的处理，无非就时遍历。在这里要比较两树，可以遍历一个节点时，去比较是否是子树，遍历一个节点时，比较时否时子树。在遍历时节点时，本身就时一个递归的实现，在判断是否是子树时，又是一个递归遍历。</p>

<p>在这种多个流程里含有递归的情况很多。必过在全排列的时候，就时一个for循环是里有一个递归</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15378464323310.html">xcode项目编译过程</a></h1>
			<p class="meta"><time datetime="2018-09-25T11:33:52+08:00" 
			pubdate data-updated="true">2018/9/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在xcode的IDE工具很少关注整个的编译过程。<br/>
实际编译过程就是buildPhases的列表，一件一件执行这里面的工作。<br/>
比如</p>

<pre><code>Check Pods Manifest.lock
runScript
Compile Sourse
Link Binary With Libraries
Copy Bundle Resources
Copy Pods Resources
RunScript
RunScript
Embed Pods Frameworks
</code></pre>

<ol>
<li><p>先检查podfile的本地使用清单与Git后的清单，保证使用的是最小的pod清单</p></li>
<li><p>runSript 执行自定义的脚本，比如提前下载编译需要的文件(这些大文件不好用git进行管理)</p></li>
<li><p>Compile Source 编译.m文件，项目中的文件</p></li>
<li><p>Link Binary  链接所有的静态库文件（包括.framework的静态库文件，.a的静态库文件）</p></li>
<li><p>Copy Bundle Resources 拷贝资源文件到可执行文件目录</p></li>
<li><p>Copy Pods Resources 拷贝Pods的资源文件到可执行的文件目录(如果pods库里包含boundle的资源文件，就会执行这个脚本，将其拷贝到可执行目录)</p></li>
<li><p>RunScript 执行自定义脚本，在这里可以执行编译完成后的一些脚本。比如有bugTag的可以上传一些符号表。</p></li>
</ol>

<p>当然执行自己的脚本方可以自己调整执行顺序。即是在编译前执行还是在编译后执行。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15372661258374.html">OFFER</a></h1>
			<p class="meta"><time datetime="2018-09-18T18:22:05+08:00" 
			pubdate data-updated="true">2018/9/18</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>简明记录一些题目相关实现原理以及注意点。</p>

<h3 id="toc_0">基本数据结构</h3>

<h4 id="toc_1">数组</h4>

<h4 id="toc_2">字符串</h4>

<h4 id="toc_3">链表</h4>

<h4 id="toc_4">树</h4>

<ul>
<li><p>树的遍历<br/>
前序遍历<br/>
中序遍历<br/>
后序遍历<br/>
主要掌握 这三种遍历的递归，与循环实现方式<br/>
层序遍历</p></li>
<li><p>树里的特例<br/>
二叉搜索树<br/>
堆<br/>
红黑树</p>

<h4 id="toc_5">栈与队列</h4></li>
</ul>

<h4 id="toc_6">递归与循环</h4>

<h4 id="toc_7">查找和排序</h4>

<ul>
<li><p>查找<br/>
顺序查找<br/>
二分查找<br/>
哈希查找<br/>
二叉排序树查找</p></li>
<li><p>排序<br/>
冒泡排序<br/>
选择排序<br/>
快速排序<br/>
归并排序</p></li>
</ul>

<h4 id="toc_8">回溯法</h4>

<p>我理解的回溯法，更多的是利用“递归”的子问题特性将返回值带回上一层。上一层有多个这个子问题的一个综合。</p>

<h4 id="toc_9">动态规划</h4>

<p>若果求一个的最优解，最大值或者最小值，而且该问题能分解成子问题。子问题能分解成更小的子问题。也就是大问题依赖于一系列的子问题的值（而不是单个问题的值，如果是单个问题的值，那么是回溯法）。在动态规划中，新的元素添加进去后，改变了原有的分配策略，也就是需要重新动态规划。</p>

<h4 id="toc_10">贪婪算法</h4>

<h3 id="toc_11">2. 单例实现</h3>

<p>注意多线程</p>

<h3 id="toc_12">3. 找出数组中重复的数字</h3>

<p>在一个长度为n的数组里的所有数字都在0~n-1的范围内。<br/>
找出数组中任意一个重复的数字。</p>

<p>一般思路<br/>
思路一：排序<br/>
排序O(nlogn)</p>

<p>思路二：搞一个hash表<br/>
O(n) 额外空间O(n)</p>

<p>思路三：根据题目给定的n的长度的数组里有0~n-1的数字这一特征。</p>

<h4 id="toc_13">3.1 不修改数组找出重复的数字</h4>

<p>在一个长度为n+1的数组里的所有数字都在1~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。</p>

<p>不能修改原数组的话<br/>
一般解法是用一个额外数组或者hash表</p>

<p><strong>优化思路</strong><br/>
<strong>分析关键，n+1的数组里所有数字在1~n里。那么我可以通过将1~n里的数组分成两组，遍历数组看哪个小组里的数目大于其本身的组内元素的数目，则这个重复的数字就在哪个小组里。重复二分就可以找到了。</strong><br/>
时间复杂度时O(nlogn),空间复杂度O（1）</p>

<p>分析思考方法<br/>
思路三的思考方法，是从特性触发。利用二分的思路。（哈哈，这就是为什么要对经典算法的深刻理解的原因了,很多问题就是对经典的问题的应用,理解了经典算法，就是见招拆招）</p>

<h3 id="toc_14">4. 二维数组中的查找</h3>

<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序。每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>

<p><img src="media/15372661258374/Xnip2018-09-20_18-30-37.png" alt="Xnip2018-09-20_18-30-37"/></p>

<p>我的思路<br/>
哈哈，这个问题，是我自己实现的就是优化思路。</p>

<p><strong>优化思路</strong><br/>
选取最右角的数字，若果该数字等于要查找的数字，则查找结束。<br/>
若果该数字小于要查找的数字，则踢出这个数字所在行。若果该数字大于要查找的数字，则踢出这个数字所在列。这样每一步都可以缩小查找范围。</p>

<h3 id="toc_15">5. 替换空格</h3>

<p>请实现一个函数，把字符串中的每个空格替换成%20,例如<br/>
&quot;We are happy&quot;输出&quot;We%20are%20happy&quot;</p>

<p>我的思路<br/>
开辟新的数组，边遍历边输出<br/>
时间复杂度O(N)*O(n),空间复杂度O(N)<br/>
如果是在原有数组的基础上，进行替换，则需要原有数组又足够的空间。<br/>
从上面的解法可以看出，多次空格时，将会有多次的后面元素的移动。<br/>
每多一个空格，就会将后面的元素多移动一遍。（这里就是优化的地方，当提出优化要求时，我们先分析有哪些需要优化的东西）</p>

<p><strong>优化思路</strong><br/>
还有一种思路，先找出有多少个空格，在遍历只做一次的移动。这时间复杂度时O(N)+O(N)，时间复杂度比上面的低。</p>

<h4 id="toc_16">5.1合并两个有序数组，合并后有序</h4>

<p>有两个排序数组A1与A2，内存在A1的末尾有足够的空间容纳A2,请实现以函数，吧A2中的所有数字插入A1中，并且是有序的。</p>

<p>简单思路<br/>
遍历A1,与A2的头比较，是的就加入到A1，并移动A1后面的东西。<br/>
这样就会有问题，没吃都会有大量的移动。O( n<sup>2</sup> )</p>

<p><strong>优化思路</strong><br/>
还是从最后的元素进行比较，大的移动到最后，维持3个指针，<br/>
A1的尙未做过移动的的指针p1，A2的最后的指针p2，A1的从后向前移动后的指针。</p>

<h3 id="toc_17">6. 从尾到头打印链表</h3>

<p>输入一个链表的头节点，从尾到头反过来打印出每个节点的值。</p>

<p>思考<br/>
一般的思路是将遍历到最后将链表反过来。然后在打印。<br/>
这样时间复杂度为O(N)*2,因为要遍历两边。</p>

<p>优化思路(嗯，就是这样的)<br/>
利用栈，或者递归，在打印的时候打印它的下一个节点。</p>

<h3 id="toc_18">7. 重建二叉树</h3>

<p>输入某个二叉树的前序遍历与中序遍历结果，请重建二叉树<br/>
假如输入的前序遍历和中序遍历的结果中都不含重复的数字。<br/>
例如<br/>
输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6} 重建二叉树</p>

<p>思路<br/>
（这个我的思路是有的，当真正实现还是花了点时间了的复习时，可以在用手在纸上写出来）<br/>
通过前序遍历确定根，根据中序遍历左右子树。然后重复这个过程，结束条件是到了叶子节点（无左右子树）</p>

<pre><code>public static void main(String[] args){
        int [] pre = {1,2,4,7,3,5,6,8};
        int [] mid = {4,7,2,1,5,3,8,6};

        TreeNode head = createTree(pre,mid ,0,pre.length-1,0,mid.length-1);

        System.out.println(&quot;前序遍历&quot;);
        printPreTree(head);
        
        System.out.println(&quot;中序遍历&quot;);
        printMidTree(head);
        
        System.out.println(&quot;后序遍历&quot;);
        printAftTree(head);
    }

    public static TreeNode createTree(int[] pre,int [] mid,int preStart,int preEnd, int midStart,int midEnd) {
        
        if(preStart &gt; preEnd || midStart &gt; midEnd){//结束条件
            return null;
        }

        //前序遍历第一个节点是根节点
        TreeNode rootNode = new TreeNode(pre[preStart]);                    

        //找到在中序遍历的根节点的位置
        int location = rootLocation(mid,pre[preStart],midStart,midEnd);     

        TreeNode lefNode = null;
        //存在左子树
        if(preStart + 1 &lt;= preStart + (midEnd - midStart)){
            lefNode = createTree(pre,mid,preStart+1,preStart + (location - midStart),midStart,location-1);
        }

        TreeNode rightNode   = null;
        //存在右子树
        if(location +1 &lt;= midEnd){
             rightNode = createTree(pre,mid,preStart + (location - midStart) +1 , preEnd,location+1,midEnd);
        }
        rootNode.left = lefNode;
        rootNode.right = rightNode;
        return rootNode;
    }

    public static int rootLocation(int[] mid , int find,int midStart, int midEnd){
        //在midStart与midEnd之间寻找根节点的值
        int location = midStart;
        while(midStart &lt;= midEnd){
            if(mid[midStart] == find){
                break;
            }
            midStart ++;
        }   
        return midStart;
    }

    //前序遍历
    public static void printPreTree(TreeNode root){
        if(root==null){
            return;
        }
        System.out.println(root.val);
        printPreTree(root.left);
        printPreTree(root.right);
    }

    public static void printMidTree(TreeNode root){
        if(root==null){
            return;
        }
    
        printMidTree(root.left);
        System.out.println(root.val);
        printMidTree(root.right);
    }

    public static void printAftTree(TreeNode root) {
        if(root == null){
            return;
        }
        printAftTree(root.left);
        printAftTree(root.right);
        System.out.println(root.val);
    }
</code></pre>

<h3 id="toc_19">8. 二叉树的下一个节点</h3>

<p>给定一颗二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点？树中的节点除了有两个分别指向左，右子节点的指针，还有一个指向父节点的指针。</p>

<h3 id="toc_20">9. 两个栈实现队列</h3>

<p>用两个栈实现一个队列，队列的声明如下，请实现它的两个函数入队与出队。</p>

<p>思路（我没有思考的很全）<br/>
假设栈A，栈B，入队时，一次入队1，2，3，4，入队时，将入队的元素依次压入栈A中。出队时，将栈A的元素依次Pop到B中，并将最上面的元素取出（这个元素就是队首元素）。如果再由元素入队时，直接入栈A，再出队时，假如栈B还有元素直接出队。没有的化，就将栈A的元素依次出队放在栈B里。</p>

<h4 id="toc_21">9.1 两个队列实现一个栈</h4>

<p>思路<br/>
对列A，队列B，依次入队1，2，3，4，入队1，入队列A，1，2，3，4，出栈时，将元素全部重新入队B。当对A只有最后一个元素时，就是出队的元素。在出队时，将队B的全部出队，留最后一个元素，就是需要出队的。入栈时直接放在非空的后面。</p>

<h3 id="toc_22">10. 斐波那契数列</h3>

<p><img src="media/15372661258374/Xnip2018-09-23_15-26-40.png" alt="Xnip2018-09-23_15-26-40"/></p>

<p>思路<br/>
从表达式可以看出用递归很好解决。</p>

<p>优化思路一<br/>
用递归表达式，因为f(n)有时候会被计算多次造成性能问题。所以只能改成循环来实现。临时记住已经计算过的值。性能更好。</p>

<p>优化思路二<br/>
还有一种用矩阵的解法logn，当要求矩阵运算。算法复杂，不太实用。</p>

<h4 id="toc_23">10.1 青蛙跳台阶</h4>

<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级台阶总共有多少种跳法。</p>

<p>思考<br/>
这里主要是考察通过分析问题能力，数学建模的能力，解决问题的能力<br/>
第n级台阶可由第n-1级台阶，也可由第n-2级台阶而来。则实际上就是上面的斐波那契数列。</p>

<h4 id="toc_24">10.2 快速排序</h4>

<p>//写出块排</p>

<h4 id="toc_25">10.3</h4>

<h3 id="toc_26">11. 旋转数组的最小数字</h3>

<p>把一个数组最开始的若干个元素搬到数组的末尾，即数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。</p>

<p>思路<br/>
     普通的遍历求最小值，当然是可行的，时间复杂度是O(n)。但失去了本题的意义。</p>

<p>优化思路<br/>
因为是部分有序的。可以通过二分查找思想，二分查找的时间复杂度时O(logn)，通过二分查找定位最小值，二分查找由递归法，也有循环法</p>

<h3 id="toc_27">12. 矩阵中的路径</h3>

<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左，右，上，下移动一格。若果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如下图求是否包含&quot;bfce&quot;的路径。<br/>
<img src="media/15372661258374/Xnip2018-09-25_21-25-35.png" alt="Xnip2018-09-25_21-25-35"/></p>

<h3 id="toc_28">13. 机器人的运动范围（我觉得这个题目有问题）</h3>

<p>地上有一个m行n列的方格。一个机器人从坐标（0，0）的格子开始移动，它每次可以向左，右，上，下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。</p>

<p>思考<br/>
感觉有两种思路，一种是直接用两个for循环<br/>
另一种是用向各个方向找，采用递归回溯的方式.<br/>
??我觉得这个题目是有问题的</p>

<h3 id="toc_29">14. 减绳子(这个问题很经典)</h3>

<p>给你一根长度为n的绳子，请把绳子剪成m段。每段绳子长度k[0],k[1],k[m],请问k[0] *k[1]...可能的最大乘积是多少。</p>

<p>思考（采用动态规划的方法，将问题建模，也是比较难的）<br/>
长度为1时，不能分割，长度是2时，分割后找出最大值是确定的。长度是3时，分割后的最大值也是确定的。这样根据数学归纳法，每增加一个长度。我可以从与前面已经算好的最长的子问题一个个根据一定的规则推出当前的最大值。而这个规则，就是比较新分隔的两数字的大小中的最大值作为最大值。</p>

<p>优化思路<br/>
采用贪婪策略，当n&gt;=5时，尽可能多的剪长度为3的绳子，当剩下的绳子长度为4时，把绳子剪成长度为2的绳子。（这个个实际上要找到一个贪心策略，说实话，需要比较高的数学能力）</p>

<h3 id="toc_30">15. 二进制中的1的个数</h3>

<p>输入一个整数，输出数二进制表示中1的个数</p>

<p>思路<br/>
采取移位操作，将一个数每右移一位。然后与1做“与”运算。<br/>
1即00001，如果不为1，那么最后一位不是1，若果是1，那么最后一位就是1，然后继续右移。直到原数被移动到为0为止。(这样负数是有问题的,因为负数的表示时在首位是1，不断右移时，最终-1时，    //-1,  100000000001,11111111111111，则构成了死循环，所以这种是有问题的)</p>

<p>为了避免循环，变相的思路<br/>
将1左移动，与原有数进行与运算，每次与运算，判定结果是否为0；为0就说明原有是1，不为0说明原有不为0；知道运行32位（假设是32位的机器）</p>

<p>优化思路（最好的解法）<br/>
把整数减去1，在和原整数做与运算，会把该整数最右边的1变成0。那么重复这么做。直到这个整数是0为止。<br/>
```<br/>
public static int numberFor1(int n ) {<br/>
        int count  = 0;<br/>
        while(n!=0) {<br/>
            n = (n - 1)&n;<br/>
            count ++;<br/>
        }</p>

<pre><code>    return count;
}
</code></pre>

<pre><code>
### 16. 数值的整数次方


</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15371495937899.html">《算法图解》</a></h1>
			<p class="meta"><time datetime="2018-09-17T09:59:53+08:00" 
			pubdate data-updated="true">2018/9/17</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>最容易读懂的算法入门书</p>

<h2 id="toc_0">O()表示法</h2>

<p>一些常见的大O表示<br/>
O(logn) 如二分查找<br/>
O(n)    如普通的线性查找<br/>
O(n * logn)<br/>
O( N<sup>2</sup> )<br/>
O(n!)</p>

<p>算法的速度 指的并非时间，而是<strong>操纵数的增速</strong><br/>
谈论算法速度时，我们说的是随着输入的增加，运行时间将一怎样的速度增加</p>

<p>随机访问<br/>
数组擅长随机访问。且在同一数组中元素类型都必须相同。（元素相同）</p>

<p>顺序访问<br/>
链表擅长顺序访问</p>

<p>数组与链表的存储<br/>
有时候将两者的结合起来存储。更快。利用了随机访问的快速，也可利用链表插入的快速</p>

<p>特别思考<br/>
<strong>在iOS中数组时可以存放不同对象类型的数据的。从这个可以推测，NSArray实际不是数组，而是由其他数据结构实现的数组的特性的数组。</strong></p>

<h2 id="toc_1">排序</h2>

<h3 id="toc_2">冒泡排序</h3>

<p>比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置。<br/>
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br/>
针对所有的元素重复以上的步骤，除了最后一个。<br/>
持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>

<h3 id="toc_3">选择排序</h3>

<p>选择排序实际上是每次将从原数据里取出最大，放到新数组的后面。时间复杂度时O( N<sup>2</sup> )<br/>
特别说明：有个小疑问？因为选择排序每次的查找都会少一个元素，为什么时间复杂度还是N<sup>2呢。n,n-1,....2和1。即O(n*</sup> n*1/2)。大O表示法省略常数。即O( N<sup>2</sup> )</p>

<p>特别说明<br/>
选择排序相比与冒泡排序只需要交换一次。</p>

<h3 id="toc_4">快速排序</h3>

<h4 id="toc_5">分治法</h4>

<p>分而治之是解决问题的的一种思路。<br/>
每一步都对问题的规模进行缩小。<br/>
<strong>分治工作原理(很重要)</strong><br/>
1. 找到简单的基线条件<br/>
2. 确定如何缩小问题规模，使其最终符合基线条线条件<br/>
（也就是基线条件是确定的，要找到将问题规模缩小的方法）<br/>
特别说明:<br/>
分治法有点类似于数学归纳法。由小确定推到大确定。</p>

<p>示例<br/>
快速排序算法是一种分治法的典范。<br/>
所以找到规模的缩小方法。</p>

<ul>
<li><p>求sum(2,4,6)的和<br/>
sum(2,4,6) = 2 + sum(4,6) ;<br/>
<strong>大规模变成一个小规模，小规模在变成小规模，最终变成一个确定的值。然后又利用小规模的值逐级计算大规模。</strong></p></li>
<li><p>快速排序<br/>
数组为空或者一个元素时本身就是有序的。<br/>
规模缩小的方法是每一个有序都包括左有序+ 基准 + 右有序<br/>
所以关键问题变成左右划分的问题了。</p></li>
</ul>

<p>下面是划分的一种方法<br/>
<img src="media/15371495937899/quicksort.png" alt="quicksort"/></p>

<p>（这个个我没有实现上面对的东西?????）<br/>
快速排序是不稳定的算法。不稳定性在于分区交换时，如果有相同的值，那个值不一定是原有的那个值了。</p>

<h3 id="toc_6">归并排序</h3>

<h3 id="toc_7">堆排序</h3>

<h2 id="toc_8">递归</h2>

<p>编写递归函数时，每个递归函数有两部分，<strong>退出条件</strong>，<strong>递归表达式</strong><br/>
在理解递归前需要理解<strong>调用栈</strong></p>

<ul>
<li>5!(5的阶乘)</li>
</ul>

<pre><code>public static int factorial(int n){
        //5的阶乘
        if(n == 1){
            return 1;
        }
        return n * factorial(n-1);
     }
</code></pre>

<ul>
<li>斐波那契数列
1、2、3、5、8、13、21</li>
</ul>

<pre><code>// 1、2、3、5、8、13、21
     public static int factorial2(int n){
        if(n == 1){
            return 1;
        }
        if(n == 2){
            return 2;
        }
        return factorial2(n -1) + factorial2(n-2);
     }
</code></pre>

<h2 id="toc_9">散列表</h2>

<p>散列函数</p>

<h2 id="toc_10">广度优先搜索</h2>

<h2 id="toc_11">图</h2>

<ol>
<li><p>广度优先搜索<br/>
用于解决无权有向图的最短路径问题</p></li>
<li><p>狄克斯特拉算法<br/>
解决有带权有向图的最短路径问题</p></li>
</ol>

<p>算法的宗旨：每次以最短路径为基准，计算其他未做过基准的节点的距离，重复。</p>

<p>示例<br/>
<img src="media/15371495937899/Xnip2018-09-17_11-56-35.png" alt="Xnip2018-09-17_11-56-35"/></p>

<p>有个疑问？狄克斯特拉算法这么保存路径<br/>
？？？？？？</p>

<ol>
<li>贝尔曼-福德算法（不是重点）
解决带负边权的图的最短路径</li>
</ol>

<h2 id="toc_12">贪婪算法</h2>

<p>找局部最优解，最总得到的就是全局的最优解。<br/>
贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。贪心算法不是对所有都能得到整体的最优解，选择贪心策略必须具备无后效性（某个状态以后的过程不会影响前面的状态）。</p>

<ul>
<li><p>教室调度<br/>
希望在这间教室上尽可能多的课。<br/>
具体做法<br/>
<strong>选出结束最早的课（贪心策略）</strong>，接下来选上节课结束后的能结束最早的课。<br/>
实际的贪心策略就是找出结束最早的课</p></li>
<li><p>背包问题</p>

<p>包能装35磅的东西，有3000美元，30磅的音响。有2000美元，20磅的电脑，有1500美元15磅的吉他。</p>

<p>采用贪心策略<br/>
先选最贵的3000美元，30磅，但容不下其他的物件。<br/>
实际的答案是可以是电脑与吉他一起放进去。<br/>
所以背包问题用贪心解决不了，这个只能得到<strong>近似值</strong>。<br/>
因为不符合无后效性。当然背包问题可以用动态规划方法找到最优解。</p></li>
<li><p>集合覆盖问题</p>

<p>全美50州的观众收听得到广播。因为每个广播播出需要支付一定的费用。所以需要决定哪些广播播出。问题变成在50州里找出能满足要求的集合（实际上每一广播的覆盖就是一个集合）。50个元素的子集合有2的n次方个，n很大时，这个值将变的很大。所以用计算机计算也是不可能的。</p>

<p>对于以上的问题只能得到<strong>近似算法</strong><br/>
贪心算法<br/>
选出这样一个广播台，即它覆盖了最多的未覆盖州。重复第一步，直到覆盖了所有的州。（至于如何找到覆盖了最多的的未覆盖，就是集合运算，比如集合的交集，差集）</p></li>
<li><p>NP完全问题(nondeterministic polynomial time)</p>

<p><em>旅行商问题</em><br/>
我们假定不知道从那里离出发的5个城市。找出前往这5个城市的最短路径。<br/>
5个城市，路线有2的5次方。加入城市在多点。就会有路线2的n次方条。这样就会是一个很大的数。</p>

<p><em>集合覆盖问题</em><br/>
上面已经讲过了</p>

<p>以上两个问题都是NP完全问题。NP完全问题，一般都是采用贪婪算法求近似值。</p>

<p><strong>NP完全问题识别</strong></p>

<ul>
<li>元素较少时算法的运行速度非常快。但随着元素的数量的增加，速度会变得非常慢。 </li>
<li>涉及到&quot;所有组合&quot;的问题通常都是NP问题</li>
<li>不能讲问题分成小问题，必须考虑各种可能的情况</li>
<li>如果问题涉及集合，集合覆盖，旅行商问题等且难以解决</li>
</ul></li>
</ul>

<h2 id="toc_13">动态规划</h2>

<p>把多阶段过程转化成一系列单个问题，利用各个阶段之间的关系或者结果，逐个求解。</p>

<p>维基百科：<br/>
动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。<br/>
通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p>

<p>示例</p>

<p><img src="media/15371495937899/IMG_0263.jpg" alt="IMG_0263"/></p>

<p>每一行都是利用上一行的计算的结果。（每一行都是上面物品的价值与重量的最优解），这里利用表来存计算结果数据。</p>

<p>小结<br/>
需要给定约束条件下优化某种之前时<br/>
问题可以分散为离散的子问题时<br/>
每种动态规划解决方案都涉及网络<br/>
单元格中的值通常就是你要优化的值<br/>
每个单元格都是一个子问题<br/>
动态规划解决方案的公式不同问题公式也不同，需要自己摸索</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15370049486631.html">读《韭菜的自我修养》</a></h1>
			<p class="meta"><time datetime="2018-09-15T17:49:08+08:00" 
			pubdate data-updated="true">2018/9/15</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>花了两小时对李笑来的这本小册子做了详细的研究。幷对一些感触表深的做了总结。</p>

<ol>
<li><p>投资者与投机者的定义的区分？</p>

<ul>
<li><p>投资者：<strong>交易前，认真研究，深入学习，交易过后，无论输赢，都要总结归纳，修正自己的观念和思考，以便完善下一次的决策</strong></p></li>
<li><p>投机者：不学习，不研究，不总结，拿来主义（拿来主义是病根）</p></li>
</ul>

<p>注释：<br/>
这个我感觉体会还是比较深的，在股票市场里，大多数人都只是拿钱投机。甚至连K线都不知道什么，不知道自己为什么买卖。在这个市场里玩的不亦乐乎。是多么可怕。</p></li>
<li><p>交易市场是零和游戏吗？<br/>
推导，牛市大多数都挣钱，挣得比亏得总是多。熊市大多数亏钱，亏得比挣得多。那么就不是零和游戏了。<br/>
经济周期在里面作祟。</p></li>
<li><p>如何打赢投资这场战？<br/>
决定输赢的不是运气，而是长期稳定的<strong>低成本现金流</strong>，还要<strong>仓位的控制</strong>。<br/>
喜欢冒险的最终都是韭菜<br/>
止损线的设置。应该根据交易的日常波动幅度。而不是自己的一项情愿<br/>
痛苦与反思，天天反思，时时刻刻反思，反思之后，再反思<br/>
回报风险比= 可能的回报/可能的风险</p>

<ul>
<li>降低可能的风险的方法
调整止损线，降低自己的风险承担
降低每次的交易金额在总资金的占比（仓位）
提高自己在场外的赚钱能力（场外现金流）</li>
<li>提升可能回报的方法
选择优质标的
选择最佳的交易时机（通过<strong>周期</strong>选择入场时机）
放长持有时间</li>
</ul></li>
<li><p>如何正确的投资，生活，投资，学习？<br/>
投资提高投资胜率<br/>
生活<br/>
工作只要做到极致就很难<br/>
学习不一定是为了拿更高的工资，只是为了满足自己的好奇心。<br/>
熊市里在场外拼命赚钱，幷学习与思考。改变自己的思考方式，因为思考带来决策，决策带来行动，行动改变命运。</p></li>
<li><p>成功的交易者永远是极少数。极少数的他们所具备的共同特征就是，他们不为表象所动，他们喜欢探索表象之下的本质。</p></li>
<li><p>抽水是人类史上唯一可以永续的商业模式。（银行，券商，交易所）<br/>
越短期的预测，越接近抛硬币<br/>
越长期的预测，越容易接近真实的逻辑判断<br/>
降低交易凭次</p></li>
<li><p>对丧失机会的极度恐慌</p></li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15364733386397.html">GCD</a></h1>
			<p class="meta"><time datetime="2018-09-09T14:08:58+08:00" 
			pubdate data-updated="true">2018/9/9</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>本篇内容<br/>
1. 死锁<br/>
2. 异步与同步概念<br/>
3. 串行与并发概念（重点）<br/>
4. dispatch_group<br/>
5. dispatch_barrier_async<br/>
6. 信号量<br/>
6. dispatch_source(重点)  </p>

<h2 id="toc_0">简介</h2>

<p>在单核的CPU里，采用分时的执行，来回在不同线程之间进行切换。在多核的CPU里可以同时多个线程，也可以切换线程。这样就实现多线程。</p>

<p>多线程带来的问题<br/>
数据竞争：多个线程更新相同的资源<br/>
死锁：线程之间相互等待<br/>
消耗大量内存：太多线程会消耗大量内存</p>

<h2 id="toc_1">死锁</h2>

<p>在GCD中，以同步分发的方式非常容易出现死锁。死锁的本质资源的相互等待。异步调用不会产生死锁。</p>

<pre><code>  dispatch_queue_t queueA;
    dispatch_sync(queueA, ^{
        dispatch_sync(queueA, ^{
            [self foo];
        });
    });
    /*
    一旦进入第二个dispatch_sync就会死锁
     它们两个在同一个线程里执行外面的正在执行，第二个会等待外面的执行完，而第二个永远都不会执行完。
     */
</code></pre>

<h2 id="toc_2">队列</h2>

<p>同步队列只是在执行任务时，顺序的从对列里去任务。在一个任务没有完时不会执行下一个任务。</p>

<p>并发队列是执行任务时，在一个任务没有执行完，可以去拿另一个任务去找线程执行。</p>

<h2 id="toc_3">异步</h2>

<p>异步操作有开启线程的权利。<br/>
同步操作没有开启线程的权利。</p>

<h2 id="toc_4">不同执行方式在不同的队列里执行</h2>

<p>同步异步在并发串行队列里的四种组合<br/>
同步与异步<strong>决定是否开启线程</strong><br/>
串行与并发<strong>决定拿任务方式</strong><br/>
任务时需要线程去执行的。也就时需要考虑，有线程没任务，有任务没线程去执行的情况。</p>

<ul>
<li>同步执行 串行队列
因为是同步，不会从线程池里拿线程执行，会在当前线程里执行下一个任务（要在当前任务执行完后）。即若果在主线程里同步执行任务。会出现<strong>死锁</strong>。</li>
</ul>

<pre><code> /*
     死锁
     */
    dispatch_queue_t queue = dispatch_get_main_queue();
    dispatch_sync(queue, ^{
        NSLog(@&quot;%@&quot;,[NSThread currentThread]);
    });
</code></pre>

<pre><code>- (void)gcdDemo1 {
    //1.创建串行队列
    dispatch_queue_t q = dispatch_queue_create(&quot;demo1_seral&quot;, DISPATCH_QUEUE_SERIAL);
    
    //2.同步执行任务
     for (int i =0; i&lt; 20; i++) {
         dispatch_sync(q, ^{
        NSLog(@&quot;demo1 %@&quot;,[NSThread currentThread]);
         });
     }
}
</code></pre>

<ul>
<li>同步执行 并发队列
因为是同步，不会开启线程，因为是并发队列，拿任务可以并发，但没有线程执行，所有还是一个一个执行</li>
</ul>

<pre><code> //1.创建串行队列
    dispatch_queue_t q = dispatch_queue_create(&quot;demo4_seral&quot;, DISPATCH_QUEUE_CONCURRENT);
    //2.同步执行任务
    for (int i =0; i&lt; 20; i++) {
        dispatch_sync(q, ^{
            NSLog(@&quot;demo3+%@, %@&quot;,@(i),[NSThread currentThread]);
        });
    }
    NSLog(@&quot;come here&quot;);
</code></pre>

<ul>
<li>异步执行 串行队列
因为是异步，可以去线程池里拿线程执行。当前是串行队列，要等一个任务执行完后才去拿下一个任务。所以还是一个一个执行</li>
</ul>

<pre><code>- (void)gcdDemo2 {
    //1.创建串行队列
    dispatch_queue_t q = dispatch_queue_create(&quot;demo2_seral&quot;, DISPATCH_QUEUE_SERIAL);
    
    //2.同步执行任务
    for (int i =0; i&lt; 20; i++) {
        dispatch_async(q, ^{
            NSLog(@&quot;demo2+%@, %@&quot;,@(i),[NSThread currentThread]);
        });
    }
    NSLog(@&quot;come here&quot;);
}
</code></pre>

<ul>
<li>异步执行 并发队列
因为是异步，可以去线程池中拿线程执行。当前是并发队列。当前任务没有执行完可以去拿下一个任务执行，因为是并发，可以从线程池里拿新的线程去执行这个任务。这时就真正实现了幷发执行。</li>
</ul>

<pre><code>- (void)gcdDemo3 {
    //1.创建串行队列
    dispatch_queue_t q = dispatch_queue_create(&quot;demo3_seral&quot;, DISPATCH_QUEUE_CONCURRENT);
    
    //2.同步执行任务
    for (int i =0; i&lt; 20; i++) {
        dispatch_async(q, ^{
            NSLog(@&quot;demo3+%@, %@&quot;,@(i),[NSThread currentThread]);
        });
    }
    NSLog(@&quot;come here&quot;);
}
</code></pre>

<ul>
<li>应用（如果将这个例子理解了，就真正理解的同步异步执行与串行并发对列）
指定一个同步任务，让所有异步任务等待同步任务执行完后才执行。
解决方法：
在一个并发队列里先执行加入这个同步任务，在加入后面两个异步任务。因为是同步任务在前，不会有开启多余的线程去执行后面的任务。当第一个执行完，执行到第二个时候，是异步的，可以开启线程执行其他的，因为是并发队列，第三个任务有线程可以用来执行。</li>
</ul>

<pre><code>- (void)gcdDemo6 {
    
    dispatch_queue_t loginQueue = dispatch_queue_create(&quot;rao-login-queue&quot;, DISPATCH_QUEUE_CONCURRENT);
    void (^task)(void) = ^(){
        dispatch_sync(loginQueue, ^{
            NSLog(@&quot;用户登录了%@&quot;,[NSThread currentThread]);
        });
        
        dispatch_async(loginQueue, ^{
            NSLog(@&quot;用户支付了%@&quot;,[NSThread currentThread]);
        });
        
        dispatch_async(loginQueue, ^{
            NSLog(@&quot;用户下载了%@&quot;,[NSThread currentThread]);
        });
    };
    dispatch_async(loginQueue, task);
}
</code></pre>

<h2 id="toc_5">dispatch group</h2>

<p>使用场景：在一个对列里并发执行完后，想执行一个操作，就可以用dispatch_group</p>

<pre><code>dispatch_queue_t queue = dispatch_queue_create(&quot;rao-queue&quot;, DISPATCH_QUEUE_CONCURRENT);
    dispatch_group_async(group, queue, ^{
        NSLog(@&quot;down load1%@&quot;,[NSThread currentThread]);
    });
    dispatch_group_async(group, queue, ^{
        NSLog(@&quot;down load2%@&quot;,[NSThread currentThread]);
    });
    dispatch_group_async(group, queue, ^{
         NSLog(@&quot;down load3%@&quot;,[NSThread currentThread]);
    });
    
    //当前面的所有
    dispatch_group_notify(group, queue, ^{
        NSLog(@&quot;所有的都执行完%@&quot;,[NSThread currentThread]);
    });
    
    //在主队列里进行更新
    dispatch_group_notify(group,dispatch_get_main_queue(), ^{
        NSLog(@&quot;所有的都执行完%@&quot;,[NSThread currentThread]);
    });
</code></pre>

<h2 id="toc_6">dispatch_barrier_async</h2>

<p>dispatch_barrier_async等待之前追加的任务执行完后，就会执行这个任务，并且不会执行下一个任务，要等这个任务执行完后，才会并发执行下一个任务。</p>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];    
    dispatch_queue_t queue = dispatch_queue_create(&quot;label&quot;, DISPATCH_QUEUE_CONCURRENT);
    static NSInteger readCount = 0;
    void(^read)(void) = ^() {
        NSLog(@&quot;这是read%@&quot;,@(readCount));
      
    };
    void(^write)(void) = ^(){
        readCount++;
        NSLog(@&quot;这是write%@&quot;,@(readCount));
        
    };
    
    dispatch_async(queue, read);
    dispatch_async(queue, read);
    dispatch_async(queue, read);
    dispatch_async(queue, read);
    
    dispatch_barrier_async(queue, write);
    
    dispatch_async(queue, read);
    dispatch_async(queue, read);
    
}
</code></pre>

<h2 id="toc_7">信号量</h2>

<p>NSMutableArray是线程不安全的，当有多个线程同时对数组进行操作的时候可能导致崩溃或数据错误。这里采用的就时信号量，所谓信号量，可以理解成一个数，占有空间时+1，走开始-1；</p>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    //并发写入数据
    dispatch_queue_t queue  = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);//创建信号量
    NSMutableArray *array = [[NSMutableArray alloc]init];
    for (int i = 0 ; i&lt;1000; i++) {
        dispatch_async(queue, ^{
            dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);//减少信号量
            [array addObject:@(i)];
        });
        dispatch_semaphore_signal(semaphore);//提高信号量
    
}
</code></pre>

<h2 id="toc_8">锁</h2>

<p>锁的部分参考<a href="https://bestswifter.com/ios-lock/">深入理解iOS开发中的锁</a><br/>
<img src="media/15364733386397/1513585102364922.png" alt="1513585102364922"/><br/>
本图来自ibireme<br/>
- OSSpinLock<br/>
自旋锁的实现原理比较简单，就是死循环。当a线程获得锁以后，b线程想要获取锁就需要等待a线程释放锁。在没有获得锁的期间，b线程会一直处于忙等的状态。如果a线程在临界区的执行时间过长，则b线程会消耗大量的cpu时间，不太划算。所以，自旋锁用在临界区执行时间比较短的环境性能会很高。</p>

<ul>
<li><p>dispatch_semaphore<br/>
dispatch_semaphore实现的原理和自旋锁有点不一样。首先会先将信号量减一，并判断是否大于等于0，如果是，则返回0，并继续执行后续代码，否则，使线程进入睡眠状态，让出cpu时间。直到信号量大于0或者超时，则线程会被重新唤醒执行后续操作。</p></li>
<li><p>pthread_mutex<br/>
pthread_mutex表示互斥锁，和信号量的实现原理类似，也是阻塞线程并进入睡眠，需要进行上下文切换。</p></li>
<li><p>NSLock<br/>
NSLock在内部封装了一个 pthread_mutex，属性为 PTHREAD_MUTEX_ERRORCHECK。</p></li>
<li><p>NSCondition<br/>
NSCondition封装了一个互斥锁和条件变量。互斥锁保证线程安全，条件变量保证执行顺序。</p></li>
<li><p>NSRecursiveLock<br/>
递归锁，pthread_mutex(recursive)的封装。</p></li>
<li><p>@synchronized：<br/>
一个对象层面的锁，锁住了整个对象，底层使用了互斥递归锁来实现。</p></li>
</ul>

<h2 id="toc_9">事件源</h2>

<p>Runloop里我们说过source_t的概念，其实与队列的源是相同的。Runloop提供对源的监控。队列也可以实现对源的监控。且都可以创建自定义源。</p>

<p>理解：dispatch都是主动添加任务到队列中，然而当系统事件发生时，我们希望做一定的工作当监听到系统事件后就会触发一个任务，并自动将其加入队列执行，这里与之前手动添加任务的模式不同，一旦将Diaptach Source与Dispatch Queue关联后，只要监听到系统事件，Dispatch Source就会自动将任务（回调函数）添加到关联的队列中。（这个概念在监听系统事件时做一定的操作时是很有用处的！！！哈哈）</p>

<p>监听事件类型<br/>
     Dispatch Source一共可以监听六类事件，分为11个类型，我们来看看都是什么：</p>

<pre><code> DISPATCH_SOURCE_TYPE_DATA_ADD：属于自定义事件，可以通过dispatch_source_get_data函数获取事件变量数据，在我们自定义的方法中可以调用dispatch_source_merge_data函数向Dispatch Source设置数据，下文中会有详细的演示。     
 DISPATCH_SOURCE_TYPE_DATA_OR：属于自定义事件，用法同上面的类型一样。
DISPATCH_SOURCE_TYPE_MACH_SEND：Mach端口发送事件。
DISPATCH_SOURCE_TYPE_MACH_RECV：Mach端口接收事件。
DISPATCH_SOURCE_TYPE_PROC：与进程相关的事件。
DISPATCH_SOURCE_TYPE_READ：读文件事件。
DISPATCH_SOURCE_TYPE_WRITE：写文件事件。
DISPATCH_SOURCE_TYPE_VNODE：文件属性更改事件。
DISPATCH_SOURCE_TYPE_SIGNAL：接收信号事件。
DISPATCH_SOURCE_TYPE_TIMER：定时器事件。
DISPATCH_SOURCE_TYPE_MEMORYPRESSURE：内存压力事件。  
</code></pre>

<ul>
<li>timer_source 示例</li>
</ul>

<pre><code> dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);
    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);
    if(time){
        dispatch_source_set_timer(timer, dispatch_walltime(NULL, 0), 1, 1);
        dispatch_source_set_event_handler(timer, ^{
            
        });
        dispatch_resume(timer);
    }
    
</code></pre>

<ul>
<li>监听度文件读事件</li>
</ul>

<pre><code>dispatch_source_t processContentsOfFile(const char *fileName) {
    //prepare the file for reading
    int fd = open(fileName,O_RDONLY);
    if(fd == -1){
        return NULL;
    }
    
    fcntl(fd,F_SETFL,O_NONBLOCK);
    
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_source_t readSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, fd, 0, queue);
    if(!readSource){
        close(fd);
        return NULL;
    }
    
    dispatch_source_set_event_handler(readSource, ^{
        
        
    });
    return nil;
}
</code></pre>

<h3 id="toc_10">取消dispatch_source</h3>

<p>当设置了Dispatch source对象将一直保持有效状态，除非手动调用dispatch_source_cancel函数来取消它。但取消了dispatch source对象后，将不能再接收到新的事件</p>

<h3 id="toc_11">暂停与恢复dispatch_source</h3>

<p>可以通过使用dispatch_suspend和 dispatch_resume函数来暂停和恢复事件传递给dispatch source对象</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15362957172406.html">iOS如何将像素显示到屏幕</a></h1>
			<p class="meta"><time datetime="2018-09-07T12:48:37+08:00" 
			pubdate data-updated="true">2018/9/7</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<hr/>

<h1 id="toc_0">绘制像素到屏幕</h1>

<p>参考文章<a href="https://www.objccn.io/issue-3-1/">绘制像素到屏幕</a></p>

<p>参考文章<a href="https://segmentfault.com/a/1190000004164291">iOS视图，动画渲染机制</a></p>

<p>本文将总结<br/>
1. 位图数据如何存储的？<br/>
2. 像素绘制到屏幕上需要经历的流程？<br/>
3. CPU的工作是什么？<br/>
4. GPU的工作是什么？<br/>
5. 离屏渲染的取舍？<br/>
6. 绘制与动画的关系？<br/>
7. 渲染性能优化的总结</p>

<h2 id="toc_1">一.像素</h2>

<p>显示在屏幕上的是什么?<br/>
当像素映射到屏幕的时候，每一个像素均由三个颜色组件构成：红，绿，蓝，透明度。三个独立的颜色单元会根据给定的颜色显示到一个像素上。例如在iPhone5的显示屏上是1136 *640个像素。</p>

<h3 id="toc_2">1.1 像素在内存里的默认布局</h3>

<pre><code>  A   R   G   B   A   R   G   B   A   R   G   B  
| pixel 0       | pixel 1       | pixel 2   
  0   1   2   3   4   5   6   7   8   9   10  11 ...
</code></pre>

<h3 id="toc_3">1.2 二维数据</h3>

<p>在实际使用像素数据时，有时会使用二位数据。就时颜色组件红，绿，蓝，alpha,每一个组件是一个数组。这样可以实现很好的对数据进行压缩或者其他处理。</p>

<h2 id="toc_4">二. 软件构成</h2>

<p><img src="media/15362957172406/Xnip2018-09-09_08-32-56.png" alt="Xnip2018-09-09_08-32-56"/></p>

<p>Display(显示屏)<br/>
GPU<br/>
GPU Driver<br/>
OpenGL<br/>
    CoreGraphics<br/>
    CoreAnimation<br/>
    CoreImage</p>

<p>GPU是一个专门为图形并发计算而量身定做的处理单元。<br/>
CoreAnimation使用CoreGraphics来做渲染。CoreGraphics在CPU里进行运算出数据，形成位图包装成纹理交给OpenGl进行操作GPU进行渲染。</p>

<h3 id="toc_5">2.1 工作大致流程</h3>

<p>GPU需要将每一个frame的纹理合成在一起。每一个纹理会占用VRAM，<br/>
CPU开始程序时，会让CPU从bundle加载一张PNG的图片并且<strong>解压</strong>它，这所有的事情都在CPU上。在显示文本时，会促进CoreText和CoreGrapic生成一个位图(coreText排版器最终也是要绘制到图片上下文)，一旦准备好，它将会被作为一个纹理上传到GPU并显示出来。但滚动或者在屏幕上移动文本时，不管怎样，同样的纹理会能够复用，CPU只需要简单告诉GPU新的位置就可以，所有GPU可以重用存在的纹理，CPU并不需要重新渲染文本，并且位图也不需要重新上传到GPU。</p>

<h2 id="toc_6">三. 纹理合成</h2>

<p>在简化的理解中，纹理相当于CoreAnimatio里的CALayer，纹理可以有位图内容，其实CALayer也是有位图内容的，对于每一个纹理，所有的纹理都以某种方式叠加在彼此的顶部。当两个纹理覆盖在一起时候，GPU要为所有像素做合成操作。</p>

<ul>
<li><p>不透明的合成<br/>
在不透明时，即opaque=yes时，不用合成，直接取上面的纹理。这样就减少了合成的时间。（这也就是为什么在做性能优化时，减少层次关系，减少不必要的透明）</p></li>
<li><p>mask合成<br/>
一个图层可以有一个和它相关联的 mask(蒙板)，mask 是一个拥有 alpha 值的位图，当像素要和它下面包含的像素合并之前都会把 mask 应用到图层的像素上去。当你要设置一个图层的圆角半径时，你可以有效的在图层上面设置一个 mask。但是也可以指定任意一个蒙板。比如，一个字母 A 形状的 mask。最终只有在 mask 中显示出来的(即图层中的部分)才会被渲染出来。<br/>
所谓的mask就是一mask的不透明区域，显示本身的内容。实际上mask也是一种合成。</p></li>
</ul>

<h3 id="toc_7">3.1 离屏渲染</h3>

<ul>
<li><p>帧缓冲区<br/>
屏幕缓存区，在屏幕上</p></li>
<li><p>屏幕外缓冲区<br/>
屏幕外缓冲区</p></li>
<li><p>哪些情况会默认会强制进行离屏渲染?<br/>
CoreAnimation为了应用mask会强制进行屏幕外渲染。<br/>
CoreAnimation设置圆角半径会进行屏幕外渲染<br/>
CoreAnimation设置阴影也会出现屏幕外渲染<br/>
设置层为光栅化layer.shouldRasterize = yes<br/>
(特别说明下，rasterize是图层的光栅化，会造成离屏渲染)</p></li>
<li><p>离屏渲染的性能取舍？<br/>
一般情况下需要避免离屏渲染，因为这是很大的消耗。直接将图层合成到帧的缓冲区（屏幕上）比先创建屏幕外缓冲区，然后将屏幕外缓冲区内容般到帧缓冲区要廉价很多。但有时候需要渲染树很复杂，可以强制离屏渲染那些图层，这样就可以缓存合成的结果。性能就会有所提升。（当使用离屏渲染时，GPU第一次会混合所有图层到一个基于新的纹理的位图缓存上，然后使用这个纹理来绘制到屏幕上）。当对这个纹理进行移动，变形等操作时，可以使用这个位图缓存。这样这部分的合成将减少很多工作。其实这就是做动画的流畅的原因。所以要不要离屏渲染，要看有取舍,一般对于静态的不经常变更的可以使用离屏，增加缓存。对于经常变更的就最好不要使用离屏。这样会增加建立屏幕外缓冲区的时间，以及屏幕内与屏幕外的切换时间。</p></li>
</ul>

<h3 id="toc_8">3.2离屏渲染检测</h3>

<p>Instrument的CoreAnimationg工具，Color Offscreen-Rendered Yellow，是检测离屏渲染。Color Hits Green and Misses Red 选项，绿色代表无论何时一个屏幕外缓冲区被复用，而红色代表当缓冲区被重新创建。</p>

<h2 id="toc_9">四. CoreAnimation与CoreGraphics与OpenGLES</h2>

<p>CoreAnimation利用CoreGraphics绘制，CoreGraphics利用OpenGLES实现绘制。。</p>

<p>OpenGLES做的就是将纹理合并，做些另外的操作，比如mask，阴影等。OpenGLES对这些有层次关系的纹理进行合成，而这些具体的操作是通过GPU来实现的（也就是通过OpenGLES来操作GPU,OpenGLES只是编程接口）。</p>

<p>CoreAnimation重要的任务是判断出哪些图层需要被重新绘制，绘制完成后会有生成bitmap,CoreAnimion里的图层有backsore，就是一这个bitmap;这个bitmap可以是读取的图片数据，也可以是利用CoreGrapics绘制的。无论是给的图片还是自己通过CrorCrapics绘制的最终，提交把这个位图数据交个生成的纹理（这个纹理与这个Layer相对应）。</p>

<h2 id="toc_10">五. CPU瓶颈与GPU瓶颈优化</h2>

<p>要在1/60里完成渲染工作，CPU与GPU的总时间不能操作这个时间。否则就会出现掉帧。<br/>
在出现性能瓶颈时, 我们采用Instrument里的，OpenGL ES Driver instrument 进行查看。</p>

<h2 id="toc_11">六. CoreGraphics</h2>

<p>CPU实现的是位图绘制，这个绘制过程是用CoreGraphics完成的，也就是通过CPU进行计算而来。我们自己画的线条，长方形，通过CPU计算，最终将数据形成与CGContext里。<br/>
当渲染系统准备好，它会调用视图图层的-display方法.此时，图层会装配它的后备存储。然后建立一个 Core Graphics 上下文(CGContextRef)，将后备存储对应内存中的数据恢复出来，绘图会进入对应的内存区域，并使用CGContextRef 绘制</p>

<ul>
<li><p>UIKit 版本的代码为何不传入一个上下文参数到方法中？<br/>
这是因为当使用 UIKit 或者 AppKit 时，上下文是唯一的。UIkit 维护着一个上下文堆栈，UIKit 方法总是绘制到最顶层的上下文中。UIGraphicsGetCurrentContext() 来得到最顶层的上下文。你可以使用 UIGraphicsPushContext() 和 UIGraphicsPopContext() 在 UIKit 的堆栈中推进或取出上下文。</p></li>
<li><p>自己创建一个位图上下文<br/>
自己创建的CGContext，那么绘制的数据在这个自己创建的CGContext里，可以用这个CGGcontext形成位图或者图片。(这里可以自己绘制然后生成图片，也可以实现异步绘制，哈哈)</p></li>
</ul>

<h3 id="toc_12">6.1 drawRect原理</h3>

<p>当你调用 -setNeedsDisplay，UIKit 将会在这个视图的图层上调用 -setNeedsDisplay。这为图层设置了一个标识，标记为 dirty，但还显示原来的内容。它实际上没做任何工作，所以多次调用 -setNeedsDisplay并不会造成性能损失。<strong>当渲染系统准备好，它会调用视图图层的-display方法.此时，图层会装配它的后备存储。然后建立一个 Core Graphics 上下文(CGContextRef)，将后备存储对应内存中的数据恢复出来，绘图会进入对应的内存区域，并使用 CGContextRef 绘制</strong>。<br/>
当你使用 UIKit 的绘制方法，例如: UIRectFill() 或者 -[UIBezierPath fill] 代替你的 -drawRect: 方法，他们将会使用这个上下文。使用方法是，UIKit 将后备存储的 CGContextRef 推进他的 graphics context stack，也就是说，它会将那个上下文设置为当前的。因此 UIGraphicsGetCurrent() 将会返回那个对应的上下文。既然 UIKit 使用 UIGraphicsGetCurrent() 绘制方法，绘图将会进入到图层的后备存储。如果你想直接使用 Core Graphics 方法，你可以自己调用 UIGraphicsGetCurrent() 得到相同的上下文，并且将这个上下文传给 Core Graphics 方法。</p>

<p>总结下：检测是否需要重绘，需要重绘，若果实现了drawRect就会生成一个相应大小的后备存储。然后调用drawRect里的代码进行绘制。将数据写入上下文，幷形成新的后备存储。幷将新的后备存储交给GPU渲染。（这里如果不需要绘制，就不要重写drawRect方法了，这样就不会生成后没有必要的备存储对象了，以免造成性能的浪费），幷切每次出现重绘时，都会执行drawRect方法。造成时间和内存浪费。可以采用自己创建位图上下文，生成图片后，赋值给视图。这样可以避免不断绘制。</p>

<h3 id="toc_13">6.2 异步绘制</h3>

<p>将一些耗时的工作，避过图片的获取，图片的解码等工作放到子线程中去做，形成图片后，在放到主线程里将图片放进去。<br/>
<code><br/>
UIImageView *view; // assume we have this<br/>
NSOperationQueue *renderQueue; // assume we have this<br/>
CGSize size = view.bounds.size;<br/>
[renderQueue addOperationWithBlock:^(){<br/>
        UIImage *image = [renderer renderInImageOfSize:size];<br/>
        [[NSOperationQueue mainQueue] addOperationWithBlock:^(){<br/>
            view.image = image;<br/>
        }];<br/>
}];<br/>
</code></p>

<h3 id="toc_14">6.3 图片解码</h3>

<p>你需要知道在 GPU 内，一个 CALayer 在某种方式上和一个纹理类似。图层有一个后备存储，这便是被用来绘制到屏幕上的位图。<br/>
在给CALayer设置图片时，CoreAnimation会将其查看这个图片时否已经解码，没解码的化话进行解码(这里就是一个优化点，可以将解码的工作全部放到子线程里进行，哈哈)。<br/>
imageNamed:从 bundle 里加载会立马解压。一般的情况是在赋值给 UIImageView 的 image 或者 layer 的 contents 或者画到一个 core graphic context 里才会解压。</p>

<h3 id="toc_15">6.4 可变尺寸的图片</h3>

<p>使用较小的图片好处<br/>
解码快<br/>
占用内存小</p>

<h2 id="toc_16">七. 完整的绘制与动画流程</h2>

<h3 id="toc_17">动画在APP内部的4个阶段</h3>

<ol>
<li><p>布局：<br/>
在这个阶段，程序设置 View/Layer 的层级信息，设置 layer 的属性，如 frame，background color 等等。</p></li>
<li><p>创建 backing image：在这个阶段程序会创建 layer 的 backing image，无论是通过 setContents 将一个 image 传給 layer，还是通过 drawRect：或 drawLayer:inContext：来画出来的。所以 drawRect：等函数是在这个阶段被调用的。</p></li>
<li><p>准备：在这个阶段，Core Animation 框架准备要渲染的 layer 的各种属性数据，以及要做的动画的参数，准备传递給 render server。同时在这个阶段也会解压要渲染的 image。（除了用 imageNamed：方法从 bundle 加载的 image 会立刻解压之外，其他的比如直接从硬盘读入，或者从网络上下载的 image 不会立刻解压，只有在真正要渲染的时候才会解压）。</p></li>
<li><p>提交：在这个阶段，Core Animation 打包 layer 的信息以及需要做的动画的参数，通过 IPC（inter-Process Communication）传递給 render server。</p></li>
</ol>

<h3 id="toc_18">动画在APP外部的2个阶段</h3>

<p>当这些数据到达 render server 后，会被反序列化成 render tree。然后 render server 会做下面的两件事：</p>

<ul>
<li><p>根据 layer 的各种属性（如果是动画的，会计算动画 layer 的属性的中间值），用 OpenGL 准备渲染。</p></li>
<li><p>渲染这些可视的 layer 到屏幕。</p></li>
</ul>

<p>如果做动画的话，最后的两个步骤会一直重复知道动画结束。</p>

<h2 id="toc_19">八. 渲染性能优化的总结</h2>

<ul>
<li><p>隐藏的绘制<br/>
UILabel将text画入backing image。也就是将文字搞成相对应的图片（文字最终都会是图片）。如果改了一个包含 text 的 view 的 frame 的话，text 会被重新绘制。</p></li>
<li><p>Rasterize<br/>
当使用layer的shouldRasterize的时候，layer会被强制绘制到一个offscreen image上，并且会被缓存起来。这种方法可以在比较复杂的不会变化的图层上。</p></li>
<li><p>离屏绘制<br/>
使用 Rounded corner， layer masks， drop shadows 的效果可以使用 stretchable images。比如实现 rounded corner，可以<strong>将一个圆形的图片赋值于 layer 的 content 的属性</strong>。并且设置好 contentsCenter 和 contentScale 属性。</p></li>
<li><p>Blending<br/>
如果一个 layer 被另一个 layer 完全遮盖，GPU 会做优化不渲染被遮盖的 layer，但是计算一个 layer 是否被另一个 layer 完全遮盖是很耗 cpu 的。将几个半透明的 layer 的 color 融合在一起也是很消耗的。</p></li>
<li><p>opaque<br/>
减少透明，减少合成时间</p></li>
<li><p>drawRect<br/>
没有必要不要在drawRect里实现。可以采用异步绘制。</p></li>
<li><p>图片解码<br/>
图片解码可以异步进行，不要在设置图片的时候解码</p></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15361293454277.html">利用Cocoapods构建自己的私有与公有库</a></h1>
			<p class="meta"><time datetime="2018-09-05T14:35:45+08:00" 
			pubdate data-updated="true">2018/9/5</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">一：Spec文件</h2>

<p>在我们第一次安装pods时，都会主动的去拉取公有的repo,其实无论是共有的还是私有的下载后都在用户的/Users/用户名/.cocoapods/repos 目录下。每一个第三库都有一个spec文件，或者你自己的私有库也应该有这个spec文件。这些spec文件就在相应的repo里。<br/>
我将我自己创建一个私有库的spec文件贴出来</p>

<pre><code>#
# Be sure to run `pod lib lint KBRCategory.podspec&#39; to ensure this is a
# valid spec before submitting.
#
# Any lines starting with a # are optional, but their use is encouraged
# To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html
#

Pod::Spec.new do |s|
  s.name             = &#39;KBRCategory&#39;
  s.version          = &#39;0.1.2&#39;
  s.summary          = &#39;KBRCategory.&#39;

# This description is used to generate tags and improve search results.
#   * Think: What does it do? Why did you write it? What is the focus?
#   * Try to keep it short, snappy and to the point.
#   * Write the description between the DESC delimiters below.
#   * Finally, don&#39;t worry about the indent, CocoaPods strips it!

  s.description      = &quot;a description KBRCategory&quot;

  s.homepage         = &#39;https://gitee.com/BlueLegend&#39;
  # s.screenshots     = &#39;www.example.com/screenshots_1&#39;, &#39;www.example.com/screenshots_2&#39;
  s.license          = { :type =&gt; &#39;MIT&#39;, :file =&gt; &#39;LICENSE&#39; }
  s.author           = { &#39;raojb@knowbox.cn&#39; =&gt; &#39;raojb@knowbox.cn&#39; }
  s.source           = { :git =&gt; &#39;https://gitee.com/BlueLegend/KBRCategory.git&#39;, :tag =&gt; s.version.to_s }
  #这里改成了不以tag版本来拉取，以最新的commit
    # s.source           = { :git =&gt; &#39;https://gitee.com/BlueLegend/KBRCategory.git&#39;}
  # s.social_media_url = &#39;https://twitter.com/&lt;TWITTER_USERNAME&gt;&#39;

  s.ios.deployment_target = &#39;8.0&#39;

  s.source_files = &#39;KBRCategory/Classes/**/*&#39;
  
  # s.resource_bundles = {
  #   &#39;KBRCategory&#39; =&gt; [&#39;KBRCategory/Assets/*.png&#39;]
  # }

  # s.public_header_files = &#39;Pod/Classes/**/*.h&#39;
  # s.frameworks = &#39;UIKit&#39;, &#39;MapKit&#39;
  s.dependency &#39;AFNetworking&#39;
end

</code></pre>

<p>里面无非就是你要提交到Cocoapods上的名字、版本号，简介、主页、License、作者信息、最低平台信息、从哪个Git上下载、需要引入的framework、那些文件需要被引入，那些文件是资源文件以及是否需要ARC的模式。</p>

<ul>
<li><p>license<br/>
用MIT就可以了，一定要正确填写不然在验证的时候验证通过</p></li>
<li><p>source<br/>
是库的地址</p></li>
<li><p>s.source_files <br/>
是要将哪些文件放入进去</p></li>
<li><p>s.subspec 添加子模块<br/>
其实可以添加子模块，所谓的子模块，就是在pods出来后有子文件夹</p></li>
</ul>

<pre><code>s.subspec &#39;Security&#39; do |ss|  
  ss.source_files = &#39;AFNetworking/AFSecurityPolicy.{h,m}&#39;
  ss.public_header_files = &#39;AFNetworking/AFSecurityPolicy.h&#39;
  ss.frameworks = &#39;Security&#39;
end  
</code></pre>

<h2 id="toc_1">二：创建公有库</h2>

<ul>
<li>向Cocoapods方面注册一个账号
这个命令会收到一份邮件，让你进行会话授权。具体机制没有研究过，当你切换电脑时，需要重新进行会话授权
<code>pod trunk register raojb@knowbox.cn &#39;rjb&#39; --description=&#39;My own computer&#39;</code></li>
</ul>

<ul>
<li><p>创建spec文件<br/>
<code>pod spec create &#39;KBCategory&#39;</code><br/>
在写好代码后，在你项目的根目录下运行，会在该项目目录下生成一个spec文件。修改这个spec文件的里的相关信息。<br/>
如果是项目已经建立好了，需要创建时，可以在根目录下执行<br/>
<code>pod spec create &#39;KBCategory&#39;</code>也会生成一个spec文件</p></li>
<li><p>验证Podspec文件<br/>
<code>pod lib lint Name.podspec</code><br/>
这一步是最坑人的地方。会有各种让你通不过的理由。比如，找不到文件，找不到Lience等。<br/>
我遇到了，spec文件与s.source_files文件路径设置的不一致问题。<br/>
开源协议文件也要生成。路径也要设置正确。</p>

<pre><code>    - ERROR | [iOS] xcodebuild: Returned an unsuccessful exit code.
</code></pre>

<p>遇到这样的错误，是编译没有通过的情况。如果自己在工程里编译通过，看是不是依赖库没有设置正确。别忘了依赖系统库也要填写。总之基本没有一次性验证通过的，具体问题具体查吧。</p>

<p>例如 <br/>
<code>s.framework  = &quot;UIKit&quot;</code> <br/>
最终你出现<code>passed validation</code>就表示验证通过。验证通过表示，你给定的环境，单独编译这部分你提供的目录下的代码能自行编译通过。</p></li>
<li><p>上传<br/>
可上传项目到Cocoapods官方的仓库里。<br/>
pod trunk push 项目名.podspec<br/><br/>
上传成功后，可以在命令行里pod search &quot;库名字&quot;,若果没有应该是有缓存，删除这个文件<br/>
<code>~/Library/Caches/CocoaPods/search_index.json</code><br/>
重新pod search就可以了。</p></li>
</ul>

<h2 id="toc_2">三：创建私有库</h2>

<p>其实创建私有库的核心过程还是跟公有库是差不多的。不管是私有库还是公有库，关注点都在于Podspec文件的书写。<strong>其实我们讲到pod trunk push 项目名.podspec这条命令，其实是默认我们的Podspec文件提交到Cocoapod的仓库(Specs),然后我们之后的pod install或者pod update都是从这个仓库中提取Podspec文件，然后根据文件里面的信息去取对应的源代码。大家可以上去找找自己的开源的Podespec文件转换成json的文件</strong>。</p>

<ul>
<li><p>建立自己的私有仓库<br/>
<code>pod repo add &#39;仓库名&#39; &#39;仓库地址&#39;</code>建立好后，可以在你的cd <code>~/.cocoapods/repos</code>目录下查看，是否有你的私有仓库。</p></li>
<li><p>写代码-&gt;写Podspec文件了-&gt;检查项目和Podspec文件-&gt;打tag<br/>
这些工作与创建公有库一样</p></li>
<li><p>提交podspec文件到仓库<br/>
公有库是pod trunk push 项目名.podspec<br/>
私有库是pod repo push &#39;私有仓库名&#39; 项目名.podspec<br/>
其实就都是讲podspec文件提交到相应的仓库里</p></li>
</ul>

<p>特别说明</p>

<h2 id="toc_3">四：使用私有库</h2>

<p>使用公有库与使用私有库的方式一样。都是在podfile文件里有一个source。这个source就是标识所要使用的源(spec文件仓库)。</p>

<pre><code>#公用的私有远程索引库源
source  &#39;git@gitee.com:BlueLegend/BlueLegendPrivateSpec.git&#39;
#github远程索引库源
source &#39;https://github.com/CocoaPods/Specs.git&#39;
platform :ios, &#39;8.0&#39;

target ‘testdown’ do
    #pod &#39;lottie-ios&#39;
    pod &#39;Masonry&#39;
    pod &#39;SDWebImage&#39;, &#39;~&gt; 4.3.0&#39;
    pod &#39;YYModel&#39;, &#39;~&gt; 1.0.4&#39;
    pod &#39;MJRefresh&#39;, &#39;~&gt; 3.1.15.3&#39;
    pod &#39;KBRCategory&#39;
end
</code></pre>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_5.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all_3.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%89%8D%E8%A8%80.html"><strong>前言&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E4%B8%AA%E4%BA%BA%E7%B3%BB%E7%BB%9F.html"><strong>个人系统&nbsp;(8)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0.html">投资笔记&nbsp;(7)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.html"><strong>软件工程&nbsp;(49)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E7%AE%97%E6%B3%95.html">算法&nbsp;(8)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.html">网络协议&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.html">iOS基础概念&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E6%BA%90%E5%88%86%E6%9E%90.html">iOS开源分析&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html">iOS性能优化&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%B7%A5%E5%85%B7%E6%B7%B1%E5%85%A5.html">iOS工具深入&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="shell%E8%84%9A%E6%9C%AC.html">shell脚本&nbsp;(9)</a>&nbsp;&nbsp;
	        
	        	<a href="C%E8%AF%AD%E8%A8%80%E6%8D%A1%E6%BC%8F.html">C语言捡漏&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Git%E5%B7%A5%E5%85%B7.html">Git工具&nbsp;(3)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html">iOS架构设计&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Swift.html">Swift&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式&nbsp;(4)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E6%8A%80%E6%9C%AF.html"><strong>音视频技术&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15512048926912.html">设计模式系列（四）-- 行为型</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15512048797799.html">设计模式系列（三）-- 结构型</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15512048653711.html">设计模式系列（二）--创建型设计模式</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15512048416439.html">设计模式系列（一）设计模式概要</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15512046578708.html">Swift梳理</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>
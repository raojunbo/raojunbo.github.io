
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  北哥传奇
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="北哥传奇" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">北哥传奇</a></h1>
  
    <h2></h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:raojunbo.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15486866737545.html">威科夫中阶课程（二）</a></h1>
			<p class="meta"><time datetime="2019-01-28T22:44:33+08:00" 
			pubdate data-updated="true">2019/1/28</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>
<a href="#toc_0">派发的原理和事件</a>
</li>
<li>
<a href="#toc_1">特征改变</a>
</li>
<li>
<a href="#toc_2">如何制定基于结构的策略</a>
</li>
<li>
<a href="#toc_3">再次吸筹</a>
</li>
<li>
<a href="#toc_4">吸收供应的特征(趋势可能向上)</a>
</li>
<li>
<a href="#toc_5">供应吞没需求的特征(趋势可能向下)</a>
</li>
</ul>


<h2 id="toc_0">派发的原理和事件</h2>

<ul>
<li><p>PSY<br/>
在上涨一定时间后卖盘开始提供明显的阻力，价格创新高，成交量增加，价差扩大，它指出上涨运动可能接近尾声</p></li>
<li><p>BC<br/>
价差的宽度和卖盘力量通常到达顶点的地方，在顶部附件，大型专业机构满足来自于公众的急切买盘。(通常成交量比前面更大)</p></li>
<li><p>AR<br/>
BC到AR，与前面的回调的成交量相比较，判断是否是AR;通常成交量较大。回调幅度较大。</p></li>
<li><p>ST<br/>
测试市场的需求是否还存在。通常看到ST后就会进入盘整时期。成交量较BC小一点</p></li>
<li><p>UT<br/>
突破后，立马回到了TR。测试A段，看需求的能力。</p></li>
<li><p>UTAD<br/>
它是对价格突破到阻力线之上所产生的需求的最后的测试。与吸筹中的Spring和终极震仓一样。</p></li>
<li><p>LPSY</p></li>
</ul>

<p>UP与JOC的区分</p>

<p>有效突破：幅度，时间（在2到3根K线，收盘都在最好在原阻力之上），成交量（适当放量，不能是天量，成交量上升意味S放大，同时D也变大，回落时成交量不能很大）</p>

<p>波动性：通常在派发时波动性较强。因为CM在达到目标时，进入派发区，留给CM的时间比较少。</p>

<h2 id="toc_1">特征改变</h2>

<ul>
<li>Main SOS
下跌趋势到横盘
比如 SC,AR,ST</li>
<li>Main SOW
横盘到上升趋势
Spring,LPS,JOC,</li>
</ul>

<h2 id="toc_2">如何制定基于结构的策略</h2>

<p>交易策略制定原则：<strong>方向，目标，时机</strong> + 衡量盈亏比</p>

<ul>
<li>定义市场背景
划出趋势线。定义时在上升趋势，还是横盘，还是下跌趋势
遇到阻力去做空，遇到支撑去做多

<ul>
<li>如果做空了的人
寻找趋势改变的迹象（SC,AR,ST）去平仓。可以在SC，AR期间，ST时平仓</li>
</ul></li>
<li><p>定义A段</p>

<p>SC到AR的目标位无法确定,AR的反弹都比较高。SC的位置也无法确定，有可能SC不是SC，而是继续SC。所以这个段最好不要做。<br/>
AR到ST的目标位知道（暂时是ST的位置），SC有可能继续下跌，即ST有可能是失败的。</p></li>
<li><p>ST确定了</p>

<ul>
<li><p>如果持有空仓的人<br/>
就应该平仓了<br/>
ST确定就表示A段已经发生了，进入B段。ST就很有可能会有横盘。B段的波动性幅度都会很大，难度很大。</p></li>
<li><p>如果此时B段后期有低点<br/>
可以去尝试做多。因为B段走一段时间后，有可能进入C段。但此时我们无法判断是C段，C段是后期走出来然后判断出来的。如果出现SOS，基本就会是C段。</p></li>
</ul></li>
</ul>

<h2 id="toc_3">再次吸筹</h2>

<ul>
<li><p>再次吸筹的形式<br/>
<img src="media/15486866737545/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-02-09%2004.57.44.png" alt="屏幕快照 2019-02-09 04.57.44"/></p></li>
<li><p>再次吸筹的分辨<br/>
只能通过对供求分析</p></li>
</ul>

<h2 id="toc_4">吸收供应的特征(趋势可能向上)</h2>

<ul>
<li><p>尝试<em>突破阻力</em>的行为，所产生的反应较小（<strong>成交量小，幅度小，价差小</strong>）<br/>
    比如：回落较小</p></li>
<li><p>尝试<em>突破阻力</em>的反应较大时，持续性较差（<strong>无跟进，不能维持成果</strong>）<br/>
    比如：有一根较大的阴线，就但后面很快没有了，又立马收回去了，被吸收了</p></li>
<li><p>最好形成HH+HL（<strong>更高的高点，或者更高的低点</strong>）</p></li>
<li><p>UA所引发的回落没有结果<br/>
    比如：它随后的走势<strong>没有出现SOW</strong>，成交量高时，是庄家需求，成交量低时，庄家没有提供供应。</p></li>
<li><p>有时候吸收以spring结束</p></li>
<li><p>波动性通常会降低（回落的结果会越来越差）</p></li>
<li><p>价格与助理争锋相对</p></li>
</ul>

<h2 id="toc_5">供应吞没需求的特征(趋势可能向下)</h2>

<ul>
<li><p>尝试<em>突破支撑</em>的行为，所产生的反应较小<br/><br/>
比如：尝试向下突破支撑，但反弹回支撑之上的力度较小</p></li>
<li><p>尝试<em>突破支撑</em>的反应较大时，持续性较差<br/>
比如：有较大的反弹，但又立马火大支撑附近。并且成交量较大。</p></li>
<li><p>最好形成LL，LH<br/>
即，更低的低点，更低的高点</p></li>
<li><p>潜在Spring/ST in |B|所引发的反弹没有结果</p></li>
<li><p>有时候吞没以UTAD结束</p></li>
<li><p>波动性通常上升（回落的结果越来越差）</p></li>
<li><p>价格与支撑针峰相对</p></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15486697437875.html">威科夫中阶课程(一)</a></h1>
			<p class="meta"><time datetime="2019-01-28T18:02:23+08:00" 
			pubdate data-updated="true">2019/1/28</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>
<a href="#toc_0">1. 现代技术分析历史</a>
</li>
<li>
<a href="#toc_1">2. 学术对技术分析的质疑</a>
<ul>
<li>
<a href="#toc_2">随机漫步理论</a>
</li>
<li>
<a href="#toc_3">有效市场假说</a>
</li>
<li>
<a href="#toc_4">自证预言</a>
</li>
<li>
<a href="#toc_5">主观成分</a>
</li>
<li>
<a href="#toc_6">无法长线分析</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">3. 道氏理论</a>
</li>
<li>
<a href="#toc_8">4. 成功交易系统的最低要求</a>
</li>
<li>
<a href="#toc_9">5. 胜率，盈亏比</a>
</li>
<li>
<a href="#toc_10">6. 价格循环VS经济循环</a>
</li>
<li>
<a href="#toc_11">7. 如何辨认价格循环中的交易机会</a>
</li>
<li>
<a href="#toc_12">8. 市场角色分类</a>
</li>
<li>
<a href="#toc_13">9. 吸筹原理和事件</a>
<ul>
<li>
<a href="#toc_14">吸筹术语</a>
</li>
<li>
<a href="#toc_15">吸筹分段与目的</a>
</li>
<li>
<a href="#toc_16">如何寻找C段的边界（即如何定义C段）</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">1. 现代技术分析历史</h2>

<ol>
<li>查尔斯 道（《股市晴雨表》），汉密尔顿，雷亚</li>
<li>威科夫，埃文斯，汉克 普鲁顿 大卫 * 怀斯（威科夫理论的继任者）</li>
<li>沙巴克  爱德华 麦吉（《股市趋势技术分析》）</li>
<li>唐奇安 （均线）</li>
</ol>

<h2 id="toc_1">2. 学术对技术分析的质疑</h2>

<h3 id="toc_2">随机漫步理论</h3>

<h3 id="toc_3">有效市场假说</h3>

<p>A股更适合威科夫理论。因为在A股市场上散户有比较少的专业度，是非理性的。</p>

<h3 id="toc_4">自证预言</h3>

<h3 id="toc_5">主观成分</h3>

<h3 id="toc_6">无法长线分析</h3>

<h2 id="toc_7">3. 道氏理论</h2>

<p>说明：威科夫理论基于道氏理论</p>

<ul>
<li>前提假设
主要趋势不会被人操纵，价格反映所有信息</li>
<li><p>主要原则 </p>

<ul>
<li><p>市场存在三种趋势</p></li>
<li><p>主要趋势分为三个阶段<br/>
Acc,Public,Dis</p></li>
<li><p>收盘价与线<br/>
关键点位的收盘价</p></li>
<li><p>相互验证<br/>
工业指数，等指数的相互验证</p></li>
<li><p>成交量的重要性</p></li>
<li><p>趋势会已知延续，直到反转信号</p></li>
</ul></li>
</ul>

<h2 id="toc_8">4. 成功交易系统的最低要求</h2>

<p><img src="media/15486697437875/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%2018.41.17.png" alt="屏幕快照 2019-01-28 18.41.17"/></p>

<h2 id="toc_9">5. 胜率，盈亏比</h2>

<p>盘整中追求高胜率（达60以上）<br/>
趋势中追求高盈亏比 （可以放弃一些胜率，比如在D段不断尝试）</p>

<p>胜率与盈亏比，交易频率的关系<br/>
<img src="media/15486697437875/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%2018.54.10.png" alt="屏幕快照 2019-01-28 18.54.10"/></p>

<h2 id="toc_10">6. 价格循环VS经济循环</h2>

<p>股市是经济的晴雨表。股市领先于经济。</p>

<ul>
<li><p>价格循环<br/>
<img src="media/15486697437875/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%2019.01.01.png" alt="屏幕快照 2019-01-28 19.01.01"/></p></li>
<li><p>价格循环影响经济循环<br/>
<img src="media/15486697437875/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-01-28%2019.01.08.png" alt="屏幕快照 2019-01-28 19.01.08"/></p></li>
</ul>

<h2 id="toc_11">7. 如何辨认价格循环中的交易机会</h2>

<ol>
<li>确定交易性质（短线，中线，长线）</li>
<li>基于交易性质，辨认出价格循环中的交易机会(在大的交易循环中找到属于符合你的交易机会)</li>
</ol>

<p>也就是不要摇摆不定。不要发现是短线机会而做了长线，也不要是做长线的而又做了短线</p>

<h2 id="toc_12">8. 市场角色分类</h2>

<ul>
<li><p>CM(优质持股人，强手)<br/>
中央汇金，社保基金,国家队</p></li>
<li><p>Public（劣质持股人，弱手）</p>

<ul>
<li>共同基金（证券投资信托基金）</li>
<li>对冲基金 （私募基金）</li>
<li>小型保险公司</li>
<li>专业交易人士</li>
<li>普通散户</li>
</ul></li>
</ul>

<p>阿尔法驱动：考验基金经理的水平<br/>
贝塔驱动：市场的平均收益，比如上证ETF</p>

<p>Tip：共同基金，对冲基金的概念？ETF的概念？</p>

<h2 id="toc_13">9. 吸筹原理和事件</h2>

<h3 id="toc_14">吸筹术语</h3>

<ul>
<li><p>PS<br/>
初步支撑，在一段长期下跌后，大量的买盘开始提供明显的支撑，当最终支撑失败，价格随后任然创新低。成交量增加，<strong>价差扩大</strong>。那么下跌有<strong>可能</strong>接近尾声。（注意是可能，也有可能继续下跌，这个需要后期走势的验证，CM有机会大量的买进，完成一些建仓任务（比如10%的建仓任务），散户此时提供的流动性，正好给了CM建仓的机会）</p></li>
<li><p>SC<br/>
市场出现恐慌，CM大量买进建立仓位（比如20%的建仓任务），散户因为害怕而卖出。经典的是大的价差，大的成交量。但也有可能是小的价差，小的成交量，然后突然上涨，原因是，可能在下跌中CM就边跌边买，公众该卖的都卖了，导致小的成交量，CM增加一点点买盘，就可以将价格迅速推高。</p></li>
<li><p>AR<br/>
卖盘被耗尽，买盘可以轻易将价格推高，随后空头平仓继续推高价格，并通常形成长期下跌以来的最高的反弹。并且定义了TR的阻力水平。<br/>
在AR处若果成交量较大，反弹力度较大，那么可能说明CM参与了反弹的购买<br/>
如果成交量较小，并且反弹力度较小，可能是一个失败的AR。<br/>
从AR的质量能大致能判定出ST的可能出现的最低点位置。</p></li>
<li><p>ST<br/>
去确认在SC的是否真的发生，也就是否还有供应。通常好的ST是比SC更高的位置停止住。或者小量。也就是公众不会在以更低的价格卖出了。</p></li>
<li><p>Spring<br/>
Spring最好是低量的，也就是不会有更低的卖盘。这个地方是机会也是风险点。</p></li>
<li><p>LPS<br/>
在D段，有一些HH,HL,都是很好的LPS。</p></li>
<li><p>JOC（Major SOS）<br/>
收盘价过区间最高点。（高量，宽价差），（低量，低价差），都可以。</p></li>
<li><p>SOS<br/>
大的价差，放大的成交量，突破短期阻力</p></li>
<li><p>BU<br/>
Backingup 回测，或者LPS</p></li>
</ul>

<h3 id="toc_15">吸筹分段与目的</h3>

<p>A段：PS，SC,AR,ST   ---》停止下跌趋势<br/>
B段：UA，ST in B持股由散户转换到CM手中，也就是换手阶段，B段早起波动性较大，看空，看多的都较多。B段成交量会越来越小。通过B段的表现，判断C段可能发生的地方。--》建立原因，测试供应，产生需求<br/>
C段：Spring,SO（Shake out）,LPS --》最后的支撑的测试<br/>
D段：SOS,LPS,JOC,BU（backUp） --》展现出摆脱区间的能力，确认阻力是否变成了支撑<br/>
E段：UpTrend（趋势分析的工具，如趋势线，均线），吸引买盘跟随（吸引公募私募专业交易者跟随推动价格进一不发展）或者再次吸收浮动供应。</p>

<p>Tip:盘感锻炼方法：手绘k线图，手绘点数图</p>

<p>我们主要在C段，D段做交易</p>

<h3 id="toc_16">如何寻找C段的边界（即如何定义C段）</h3>

<p>找到前期局部支撑<br/>
刺穿前期局部支撑，<strong>左边界</strong><br/>
收盘又在局部支撑之上，<strong>右边界</strong></p>

<ul>
<li><p>局部支撑怎么找？</p>

<p>良好的需求柱的底部 <br/>
ST</p></li>
<li><p>总结</p>

<p>如果是LPS，寻找前期支撑<br/>
如果是Spring,就是ST的价格位置</p></li>
</ul>

<blockquote>
<p>支撑位要素<br/>
成交量，长时间，最近的支撑</p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15462987177847.html">GCD源码核心概念</a></h1>
			<p class="meta"><time datetime="2019-01-01T07:25:17+08:00" 
			pubdate data-updated="true">2019/1/1</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li><p>dispatch_queue<br/>
<img src="media/15462987177847/c8319b785fd73afa2150a3710190f3cd.png" alt="c8319b785fd73afa2150a3710190f3cd"/><br/>
从这张图中能看出，我们创建的dispatch_queue_t实际上是统一由GCD Thread Pool来进行统一管理。他会根据多线程队列设置的Priority，来统一管理执行的优先级。</p></li>
<li><p>dispatch_async<br/>
dispatch_async的流程是用链表保存所有提交的block，然后在底层线程池中，依次取出block并执行；而向主队列提交block则会向主线程的Runloop发送消息并唤醒Runloop，接着会在回调函数中取出block并执行。主线程，专门有个存储queue里需要执行的代码段。当执行到主线程的一个循环玩了后，会从这些队列里拿任务一个一个去执行。</p></li>
</ul>

<blockquote>
<p>当我们调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调<code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</code> 里执行这个 block</p>
</blockquote>

<ul>
<li>dispatch_sync</li>
</ul>

<blockquote>
<p>理解dispathch_sync 在执行的时候,会<strong>阻塞 上下文 任务</strong>的执行.</p>

<p>造成死锁的情况<br/>
在主线程里执行<code>dispatch_sync(dispatch_main_queue,block);</code>即，上下文环境是主线程，要将任务放到主线程里执行，而且是同步的。dispatch_sync会阻塞当前主线程，又要在主线程里执行block，所以会造成死锁。造成死锁的原因是“当前执行的上下文环境”与“即将要执行的任务也是这个环境&quot;且是同步执行。同步执行不会开启新的线程，会在当前线程里执行。（所以<strong>同步执行将任务放到哪种队列没有关系，任务会在当前线程执行</strong>）哈哈哈。这个三个条件到达时就会死锁。终于弄懂了。</p>
</blockquote>

<p><strong>同步，异步的概念始终与当前执行代码的上下文线程有关系。同步就是讲当前放到其他队列里的任务拿到当前线程执行，执行完后然后返回，继续执行，执行完后返回，继续执行下面的代码。（也就说可以把加到其他队列里的任务拿到当前上下文的线程里去执行）。</strong></p>

<ul>
<li><p>dispatch_semaphore</p></li>
<li><p>dispatch_source<br/>
dispatch_source是BSD系统内核kqueue的包装，kqueue() 生成一个<strong>内核事件队列</strong>，返回该队列的文件描述符。kqueue是在XNU内核中发生各种事件时，在应用程序编程方执行处理的技术。操作dispatch_source实际上就是，通过操作这个 kqueue，进而对内核事件的处理。（哈哈，这个终于可以解释通了）相当于可以监听内核的事件，然后给一个回调，并将回调的代码在指定的线程里面执行。</p>

<p>特别说明：<br/>
这里的dispatch_source与runloop里的source还是有区别的。dispatch_source是   内核事件，runloop的source是端口事件（线程通信的方式），timer事件源（runloop的Timer依赖于线程的runloop）。</p></li>
</ul>

<p>重要理解<br/>
<strong>dispatch_asyn与dispatch_syn，dispatch_queue,任务队列是任务列，只管装任务。至于是在当前上下文线程，还是开启新的线程执行，是由同步还是异步决定的。同步不用新的线程执行，异步有创建新线程的权利。</strong></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15459973166637.html">iOS UI视图相关深入</a></h1>
			<p class="meta"><time datetime="2018-12-28T19:41:56+08:00" 
			pubdate data-updated="true">2018/12/28</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">iOS事件传递的需要思考的问题</h2>

<pre><code>- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {}
最终将这个fitView给了谁?
</code></pre>

<pre><code>- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { }
到底是谁在调用的?
</code></pre>

<blockquote>
<p>经研究，最终将这个view给了UIWindow,UIWindow调用这个fitView得touchBegan方法。</p>
</blockquote>

<p>整个事件首先在Application的事件队列里，然后通过UIWindow在view层级里是先从最后面的子view进行hitTest;找到fitView,然后将touch事件派发给它处理。或者view里有手势会先派发事件给手势处理。手势识别后会取消派发给fitView，UIWindow会调用fitView的touchBegan方法。后面的响应链条上touchBegan会被Pre-responder调用。若果不重写touchBegan，pre-responder会默认递归回溯调用。</p>

<ul>
<li><p>手势识别的内部调用机制?</p></li>
<li><p>TouchBegan，UIControl，手势识别关系?</p></li>
</ul>

<h2 id="toc_1">iOS 布局</h2>

<h3 id="toc_2">Frame布局</h3>

<p>layoutSubviews，不手动调用<br/>
layoutIFNeeded()，在同一个循环里如果需要更新就执行layoutSubviews，然后放回。也就是在layoutIFNeeded里会做判定并且调用本类的layoutSubviews；</p>

<p>setNeedsLayout()，只要告诉标记需要更新界面，在下一个循环里会有一个检测是否需要更新UI布局的一个点来执行layoutSubviews，</p>

<ul>
<li>drawRect
这是一个被重复调用的函数。重复调用会造成内存问题。</li>
</ul>

<h3 id="toc_3">自动布局</h3>

<ol>
<li>更新约束</li>
<li>布局阶段</li>
<li>显示</li>
</ol>

<p>updateConstraints()，不手动调用和layoutSubviews类似<br/>
updateConstraintsIfNeeded()， 和layoutIfNeeded类似<br/>
setNeedsUpdateConstraints()，和setNeedsLayout类似</p>

<p>intrinsicContentSize 属性，根据内容自然得到的属性。</p>

<h3 id="toc_4">视图布局更新与runloop的关系</h3>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15458865236455.html">讨论架构时是在说什么</a></h1>
			<p class="meta"><time datetime="2018-12-27T12:55:23+08:00" 
			pubdate data-updated="true">2018/12/27</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>调用网络API<br/>
页面展示<br/>
数据的本地持久化<br/>
动态部署方案</p>

<h2 id="toc_0">那么需要解决的问题</h2>

<ul>
<li><p>网络层设计方案？<br/>
设计网络层需要考虑哪些问题？<br/>
网络层的优化从哪里入手？</p></li>
<li><p>页面展示层设计方案？<br/>
页面的展示，调用，组织都有哪些设计方案</p></li>
<li><p>本地持久化的设计方案有哪些？</p></li>
<li><p>要实现动态部署，都有哪些方案</p></li>
</ul>

<h2 id="toc_1">软件架构的思路</h2>

<ol>
<li>要解决的问题（问题是什么）</li>
<li>问题分类，用不同的模块解决不同类型的问题</li>
<li>搞清楚各个问题之间的依赖关系</li>
<li>推演预测未来可能的走向</li>
<li>先实现基础模块，在用基础模块堆积整个架构</li>
</ol>

<h2 id="toc_2">View层的组织和调用方案</h2>

<p>架构模式</p>

<ol>
<li><p>如何划分MVC<br/>
M,V,C<br/>
在服务端的开发中V主要是指浏览器。<br/>
在iOS开发中V主要是指self.view的容器</p></li>
<li><p>MVCS<br/>
将C的<strong>数据储存部分</strong>抽离出来，交给另一个对象去做，即store</p></li>
<li><p>MVVM<br/>
将C的<strong>数据处理</strong>部分抽离出来，交给viewModel处理。即vm<br/>
而C负责View与ViewModel之间的绑定，以及UI逻辑处理</p></li>
<li><p>VIPER<br/>
(不懂)</p></li>
</ol>

<p>总结：这些架构都是在MVC的基础上拆分出来的。天下架构出MVC，拆分方式的不同衍生出不同的架构。</p>

<h2 id="toc_3">是否应该使用BaseViewController？</h2>

<p>尽可能<strong>不使用继承</strong>而是使用<strong>组合</strong>或者<strong>面向切面编程的AOP</strong>来替代。</p>

<ul>
<li>好处</li>
<li>业务方集成成本小。（因为如果用了继承会导致，在集成到其他APP里时，需要依赖很多东西，打动干戈）</li>
<li>新用户上手接收成本也减少了</li>
<li><p>架构维护成本低</p></li>
<li><p>目标</p></li>
<li><p>业务方可以不用继承的方法，然后框架能够做到ViewController的统一配置。</p></li>
<li><p>业务方即使脱离框架环境，</p></li>
</ul>

<h2 id="toc_4">解耦定义</h2>

<p>代码里不相互依赖，依赖分两种，单向依赖，双向依赖。</p>

<h2 id="toc_5">组件化的定义</h2>

<p>让高层模块单向依赖低层模块，业务模块之间完全解耦</p>

<h2 id="toc_6">解耦的几种方式</h2>

<ol>
<li>代理</li>
<li>block</li>
<li>通知</li>
<li>kvo</li>
</ol>

<h2 id="toc_7">组件通信实现</h2>

<ol>
<li>runtime反射机制在Mediator里的实现，在通过对Mediator的category进行接口分离(本质是runtime的反射机制)</li>
<li>通过在Mediator里注册block,一般是进行url与block的映射（本质是存block）</li>
<li>同过在Mediator里注册protocal（本质是存class）</li>
</ol>

<p><strong>总结下：业务层可以依赖基础库，但业务层要相互不依赖。就需要依赖一个可以连接两个业务层的东西Mediator。为了防止业务层又与Mediator相互依赖。这里只允许业务层单向依赖Mediator。其实解耦可以是任意两个类之间实现单向依赖。只是将解耦应用到了对Mediator的单向依赖上。</strong></p>

<h2 id="toc_8">组合与继承的选择</h2>

<p>组合与继承都可以实现代码的复用<br/>
1. 除非两个类之间是<strong>&quot;is-a&quot;</strong>的关系，否则不要轻易使用继承<br/>
2. 两个类之间是<strong>has a</strong>的关系时，最好用组合</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15454940280965.html">Xcode里的Instruments的应用</a></h1>
			<p class="meta"><time datetime="2018-12-22T23:53:48+08:00" 
			pubdate data-updated="true">2018/12/22</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">TimerPofile</h2>

<p>可以查看应用程序的那个方法耗时比较长，然后针对性优化</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15453886088422.html">数据结构与算法之美(专栏)</a></h1>
			<p class="meta"><time datetime="2018-12-21T18:36:48+08:00" 
			pubdate data-updated="true">2018/12/21</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">复杂度分析</h2>

<p>时间复杂度</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15453592839286.html">Git 拾遗</a></h1>
			<p class="meta"><time datetime="2018-12-21T10:28:03+08:00" 
			pubdate data-updated="true">2018/12/21</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>
<a href="#toc_0"><code>.git</code>文件目录</a>
</li>
<li>
<a href="#toc_1">commit,tree,block关系</a>
</li>
<li>
<a href="#toc_2">分离头指针情况的注意事项（没有与branch进行关联）</a>
</li>
<li>
<a href="#toc_3">修改commit的message</a>
</li>
<li>
<a href="#toc_4">rebase操作</a>
<ul>
<li>
<a href="#toc_5">修改以往的任何一个commit的message(rebase)</a>
</li>
<li>
<a href="#toc_6">合并以往的连续的几个commit（rebase）</a>
</li>
<li>
<a href="#toc_7">合并以往的不连续的commit(rebase)</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">diff操作</a>
</li>
<li>
<a href="#toc_9">恢复工作区，恢复索引区</a>
</li>
<li>
<a href="#toc_10">删除，重命名文件</a>
</li>
<li>
<a href="#toc_11">ignore文件</a>
</li>
</ul>


<h2 id="toc_0"><code>.git</code>文件目录</h2>

<pre><code>➜  .git git:(V.12.0) ls -l
total 1440
-rw-r--r--    1 raojunbo  staff      26 12 15 15:40 COMMIT_EDITMSG
-rw-r--r--    1 raojunbo  staff    1573 12 18 19:12 FETCH_HEAD
-rw-r--r--    1 raojunbo  staff      23 12 18 19:12 HEAD
-rw-r--r--    1 raojunbo  staff      41 12 18 19:12 ORIG_HEAD
-rw-r--r--    1 raojunbo  staff     551 12 12 12:56 config
-rw-r--r--    1 raojunbo  staff      73 11 30 11:39 description
-rw-r--r--    1 raojunbo  staff  311844 12 20 22:54 gitk.cache
drwxr-xr-x   13 raojunbo  staff     416 11 30 11:39 hooks
-rw-r--r--    1 raojunbo  staff  391258 12 20 22:48 index
drwxr-xr-x    3 raojunbo  staff      96 11 30 11:39 info
drwxr-xr-x    4 raojunbo  staff     128 11 30 11:42 logs
drwxr-xr-x  256 raojunbo  staff    8192 12 14 14:58 objects
-rw-r--r--    1 raojunbo  staff    1536 11 30 11:42 packed-refs
drwxr-xr-x    5 raojunbo  staff     160 11 30 11:42 refs
</code></pre>

<ul>
<li><p>HEAD 文件<br/>
存有当前分支的头指针。在切换分支的时候，会跟随分支的变化而变化。当然也可以不与分支挂钩，直接指向一个处理分支状态（任意指向的）也可以。</p></li>
<li><p>config 文件</p>

<p><code>git config -l</code>命令的内容</p></li>
</ul>

<ul>
<li><p>ORIG_HEAD 文件</p></li>
<li><p>FETCH_HEAD 文件</p></li>
<li><p>object目录<br/>
对象集，block ,commit,tree,tags;</p></li>
<li><p>refs</p></li>
</ul>

<blockquote>
<p>git内部的命令<br/>
查看hash所代表的对象类型 `<code>git cat-file -t 005642f3c41eecb8c56b8b77c4f100f1575ccf54</code></p>

<p>查看hash所代表的对象实际内容<code>git cat-file -p 005642f3c41eecb8c56b8b77c4f100f1575ccf54</code></p>
</blockquote>

<h2 id="toc_1">commit,tree,block关系</h2>

<p><img src="media/15453592839286/gitbloctree.png" alt="gitbloctree"/></p>

<p>blob实际就是真实的文件<br/>
tree实际就是目录<br/>
commit是git里的东西是一个包含“根tree”的东西。commit里有parent(父commit),author(作者),committer(提交者)</p>

<h2 id="toc_2">分离头指针情况的注意事项（没有与branch进行关联）</h2>

<pre><code>➜  GitTestDir git:(master) git checkout 552aa3eba30936d5c4ecf148b38d0cbc89221fbc 
Note: checking out &#39;552aa3eba30936d5c4ecf148b38d0cbc89221fbc&#39;.

You are in &#39;detached HEAD&#39; state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b &lt;new-branch-name&gt;

HEAD is now at 552aa3e add sty
➜  GitTestDir git:(552aa3e) 
</code></pre>

<p>直接切换到一个指定的commit号，直接进入工作后，进行提交，如果在checkout 到其它分支，就会出现分离头指针，也就是没有基于某个分支。在后期，分支的指针会自动被清理掉。</p>

<p>git diff HEAD HEAD^     //head与父亲进行对比<br/>
git diff HEAD HEAD<sup>^</sup>   //head 与父亲的父亲进行对比<br/>
git diff HEAD HEAD~1    //head 与父亲进行对比</p>

<h2 id="toc_3">修改commit的message</h2>

<p>对最近一次的message做修改<br/>
<code>git commit --amend</code></p>

<h2 id="toc_4">rebase操作</h2>

<h3 id="toc_5">修改以往的任何一个commit的message(rebase)</h3>

<p>示例<br/>
<code><br/>
commit3<br/>
commit2<br/>
commit1<br/>
</code><br/>
我现在要，修改commit2,那么我就是git rebase -i commit1;以commit1作为基准,去修改其后面的commit信息。<br/>
rebase 命令的交互命令里有拿出commit,重新设置messge等操作。<br/>
修改后commit的commit号会发生变化。</p>

<h3 id="toc_6">合并以往的连续的几个commit（rebase）</h3>

<p>示例<br/>
<code><br/>
commit4<br/>
commit3<br/>
commit2<br/>
commit1<br/>
</code><br/>
合并commit2,与commit3为commit5;这样就会形成一个新的commit;</p>

<h3 id="toc_7">合并以往的不连续的commit(rebase)</h3>

<p>其实与前面一样，只是，列出commit ，然后描述命令</p>

<h2 id="toc_8">diff操作</h2>

<ul>
<li><p>比较工作区，索引区,HEAD的差异<br/>
<code>git diff --cached</code>  比较索引区域HEAD的差别比较<br/>
<code>git diff</code> 工作区与索引区的差别</p></li>
<li><p>比较不同分支的同一个文件的差异</p></li>
</ul>

<p><code>git diff temp master -- filename</code><br/>
temp是一个分支或者commitid，master是一个分支或者commitid；</p>

<h2 id="toc_9">恢复工作区，恢复索引区</h2>

<ul>
<li>清空工作区</li>
</ul>

<p><code>git checkout file</code><br/>
<code>git checkout .</code></p>

<ul>
<li>将加入索引的放入工作区</li>
</ul>

<p><code>git reset HEAD</code></p>

<ul>
<li>清除最近的几个commit</li>
</ul>

<p><code>git reset --hard  commitid</code></p>

<h2 id="toc_10">删除，重命名文件</h2>

<ul>
<li>重命名文件
<code>git mv filename1 filename2</code></li>
</ul>

<ul>
<li>删除文件
<code>git rm filename</code></li>
</ul>

<h2 id="toc_11">ignore文件</h2>

<p><code>.gitignore</code>告诉哪些不需要加入git的管理里</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15448598664160.html">网络协议总结</a></h1>
			<p class="meta"><time datetime="2018-12-15T15:44:26+08:00" 
			pubdate data-updated="true">2018/12/15</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">网络协议层次</h2>

<p>应用层：HTTP,HTTPS,RTMP,DHCP,DNS,P2P<br/>
传输层：TP，UDP<br/>
网络层：IP,ICMP,OSPF,BGP<br/>
链路层：ARP,VLAN,STP<br/>
物理层</p>

<h2 id="toc_1">2层设备，3层设备</h2>

<h2 id="toc_2">IP</h2>

<h3 id="toc_3">IP组成</h3>

<p>IP地址由网络地址和主机地址共同组成。下面两种分类方法去定义IP的网络地址与主机地址。<br/>
- 传统地址分类<br/>
A,B,C,D类，现在基本不用</p>

<ul>
<li>无类型域间选路即CIDR（<strong>目前采用的方案，泳衣解决传统分类IP浪费的问题</strong>）

<ul>
<li>子网掩码的表示形式</li>
<li>16.158.165.91/22</li>
</ul></li>
</ul>

<h3 id="toc_4">公有IP地址和私有IP地址</h3>

<p>将<code>192.168.0.0~192.168.255.255</code>之间的地址定义为私有地址。也就是在同一公有IP的网络里唯一，在不同的IP网络里可能相同。这样在结合NAT技术解决通讯问题。<strong>这是目前采用的方案，用以解决IP即将耗尽的问题</strong></p>

<h2 id="toc_5">动态主机配置协议(DHCP)</h2>

<h2 id="toc_6">ARP协议</h2>

<ul>
<li><p>集线器<br/>
全部是用广播</p></li>
<li><p>交换机<br/>
刚开始是广播，通过自学习能力的完善转发表，知道了到达的MAC地址的设备口。就可以定向转发。</p></li>
</ul>

<h2 id="toc_7">ICMP协议</h2>

<p><img src="media/15448598664160/23aecf653d60dd94b7c5c6dc21ca21ff.jpg" alt="23aecf653d60dd94b7c5c6dc21ca21ff"/></p>

<ul>
<li><p>ping <br/>
就是利用ICMP协议的<strong>查询报文</strong></p></li>
<li><p>traceroute<br/>
就是利用ICMP的<strong>差错报文</strong></p></li>
</ul>

<h2 id="toc_8">公有IP与私有IP的应用</h2>

<p>有NAT路由设备，将公有IP映射成私有IP,进关,将私有IP映射成公有IP，出关。此种模式就是”玄奘西行&quot;，在出关时需要换成公有IP。即很多路由器支持的NAT转换。这里的公网就是运营商的地址。<br/>
那么这个这里有个疑问，isp服务商</p>

<h2 id="toc_9">路由协议</h2>

<ul>
<li>静态路由策略（手动配置）</li>
<li>动态路由算法(自动配置)
距离矢量路由算法,基于距离矢量路由算法的BGP
链路状态路由算法,基于链路状态路由算法的OSPF</li>
</ul>

<h2 id="toc_10">传输层</h2>

<p>UDP与TCP的区别<br/>
所谓的建立连接，是为了在客户端和服务端连接，而建立一定的数据结构来维护双方交互的状态(连接实际上就是<strong>连接就是两端的状态维护</strong>)。用这样的数据结构来保证所谓的面向连接的特性。<br/>
TCP提供可靠交付。保证数据的无差错，不丢失，不重复，并按顺序到达。<strong>是一种由状态的服务</strong>。提供拥塞控制。</p>

<p>UDP<br/>
UDP继承了IP数据报的原始特性，一个个发一个个地接收。不管网络情况，一个劲的发。</p>

<ul>
<li>UDP
<img src="media/15448598664160/6d1313f51b9dfd7ab454b2cef1cb37bf.jpg" alt="6d1313f51b9dfd7ab454b2cef1cb37bf"/></li>
</ul>

<p>UDP的几个例子<br/>
1. Google推出的QUIC是基于UDP改进的通信协议，其目的是降低网路通信的延迟<br/>
2. 很多直播都会基于UDP实现自己的视频传输协议<br/>
3. 很多实时游戏会采用自定义的可靠UDP协议，来自定义重传策略，将丢包降低到最低<br/>
4. 物联网，很多嵌入式设备不能处理打量的数据结构，基于UDP实现网络通信</p>

<ul>
<li>TCP
<img src="media/15448598664160/a795461effcce686a43f48e094c9adbf.jpg" alt="a795461effcce686a43f48e094c9adbf"/>
TCP的三次握手
为什么是三次握手：保证双方的消息都<strong>有去有回</strong>。就是建立连接了。</li>
</ul>

<p>TCP的四次分手<br/>
分手过程，要保证各端的数据都发送完了。才真正结束。</p>

<p>顺序问题<br/>
超时重传<br/>
流量控制<br/>
拥塞控制</p>

<h2 id="toc_11">应用层协议</h2>

<ul>
<li>HTTP</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15447065945223.html">*# 威科夫高阶结构课程</a></h1>
			<p class="meta"><time datetime="2018-12-13T21:09:54+08:00" 
			pubdate data-updated="true">2018/12/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">ART</h2>

<h2 id="toc_1">吸筹的分段规则</h2>

<p><img src="media/15447065945223/Xnip2018-12-14_05-36-23.png" alt="Xnip2018-12-14_05-36-23"/></p>

<ul>
<li><p>A段<br/>
A段的ST,测试前面的BC，是否还有足够的供应。测试短期内极端的市场行为是否结束。</p></li>
<li><p>B段<br/>
B段ST，测试前面A段的供应是否消耗完。波动性较大。B段CM操纵的比较最多的，只有CM才能使下跌趋势停止。</p></li>
<li><p>C段<br/>
C段ST,测试前面的B段的供应是否消耗完</p></li>
<li><p>D段<br/>
D段ST，对前面的测试最后供应测试，若果是低量，则是成功的测试。</p></li>
</ul>

<p>一般吸筹都会有三次以上的分段测试，去测试供应是否还存在。</p>

<h2 id="toc_2">TR区间交易的选择</h2>

<h3 id="toc_3">BC</h3>

<p>想在BC底部买？<br/>
很难捕捉到这个AR。一是难以确定反弹目标，只能用阻力区确认。但在这这里的确认，一般不确定。而且这里抄底是是逆势交易。<strong>不建议交易</strong>。</p>

<h3 id="toc_4">AR</h3>

<p>想在AR卖？<br/>
首先确认这个就是AR，AR有时可能不是AR（即不是横盘），而是突破BC的最低点，形成新的下跌趋势。所以AR做空<strong>可以尝试做空</strong>。</p>

<h3 id="toc_5">第一次测试</h3>

<p>进入交易区间，选择做这个TR（交易区间）。从结构上来讲，可以做TR短期交易。当越来越来向右发展时，就要比较小心了。停止短期交易，观察选择市场选择方向。</p>

<h3 id="toc_6">B段二次恐慌或者Spring</h3>

<p>在B段，或者C段里都可能出现震仓，或者Spring<br/>
特征：下跌幅度较大（与其前面的相比较），或者价差较大。有一定的成交量(成交量越小越好)，击穿密集区然后立马回到TR内。</p>

<h3 id="toc_7">C段</h3>

<p>C段特征是低量测试。</p>

<h3 id="toc_8">D段的LPS</h3>

<p>特征是测试时，低量并且，底部比前面都高，<strong>最佳买入点</strong></p>

<h3 id="toc_9">D段的JOC</h3>

<p>在突破平台后，通过左手边的震荡可以通过点数图算出目标位。突破形成JOC,<strong>次佳买入点</strong></p>

<blockquote>
<p>复盘方法：辨认好的交易时机，不要的交易时机。我在哪里做了交易。我为什么没有识别出这些交易。<br/>
要以wave波的形式去理解（很重要）。而不是一根根K线。</p>
</blockquote>

<p>如何区分，二次恐慌是吸筹的二次恐慌，而不是在次的派发。</p>

<h3 id="toc_10">E段的主升浪</h3>

<p>*</p>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_2.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%89%8D%E8%A8%80.html"><strong>前言&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E4%B8%AA%E4%BA%BA%E7%B3%BB%E7%BB%9F.html"><strong>个人系统&nbsp;(10)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0.html">投资笔记&nbsp;(9)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.html"><strong>软件工程&nbsp;(49)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E7%AE%97%E6%B3%95.html">算法&nbsp;(8)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.html">网络协议&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.html">iOS基础概念&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E6%BA%90%E5%88%86%E6%9E%90.html">iOS开源分析&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html">iOS性能优化&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%B7%A5%E5%85%B7%E6%B7%B1%E5%85%A5.html">iOS工具深入&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="shell%E8%84%9A%E6%9C%AC.html">shell脚本&nbsp;(9)</a>&nbsp;&nbsp;
	        
	        	<a href="C%E8%AF%AD%E8%A8%80%E6%8D%A1%E6%BC%8F.html">C语言捡漏&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Git%E5%B7%A5%E5%85%B7.html">Git工具&nbsp;(3)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html">iOS架构设计&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Swift.html">Swift&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式&nbsp;(4)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E6%8A%80%E6%9C%AF.html"><strong>音视频技术&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15512048926912.html">设计模式系列（四）-- 行为型</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15512048797799.html">设计模式系列（三）-- 结构型</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15512048653711.html">设计模式系列（二）--创建型设计模式</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15512048416439.html">设计模式系列（一）设计模式概要</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15512046578708.html">Swift梳理</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>
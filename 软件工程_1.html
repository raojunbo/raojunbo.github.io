
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  软件工程 - 北哥传奇
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="北哥传奇" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">北哥传奇</a></h1>
  
    <h2></h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:raojunbo.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15453592839286.html">Git 拾遗</a></h1>
			<p class="meta"><time datetime="2018-12-21T10:28:03+08:00" 
			pubdate data-updated="true">2018/12/21</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>
<a href="#toc_0"><code>.git</code>文件目录</a>
</li>
<li>
<a href="#toc_1">commit,tree,block关系</a>
</li>
<li>
<a href="#toc_2">分离头指针情况的注意事项（没有与branch进行关联）</a>
</li>
<li>
<a href="#toc_3">修改commit的message</a>
</li>
<li>
<a href="#toc_4">rebase操作</a>
<ul>
<li>
<a href="#toc_5">修改以往的任何一个commit的message(rebase)</a>
</li>
<li>
<a href="#toc_6">合并以往的连续的几个commit（rebase）</a>
</li>
<li>
<a href="#toc_7">合并以往的不连续的commit(rebase)</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">diff操作</a>
</li>
<li>
<a href="#toc_9">恢复工作区，恢复索引区</a>
</li>
<li>
<a href="#toc_10">删除，重命名文件</a>
</li>
<li>
<a href="#toc_11">ignore文件</a>
</li>
</ul>


<h2 id="toc_0"><code>.git</code>文件目录</h2>

<pre><code>➜  .git git:(V.12.0) ls -l
total 1440
-rw-r--r--    1 raojunbo  staff      26 12 15 15:40 COMMIT_EDITMSG
-rw-r--r--    1 raojunbo  staff    1573 12 18 19:12 FETCH_HEAD
-rw-r--r--    1 raojunbo  staff      23 12 18 19:12 HEAD
-rw-r--r--    1 raojunbo  staff      41 12 18 19:12 ORIG_HEAD
-rw-r--r--    1 raojunbo  staff     551 12 12 12:56 config
-rw-r--r--    1 raojunbo  staff      73 11 30 11:39 description
-rw-r--r--    1 raojunbo  staff  311844 12 20 22:54 gitk.cache
drwxr-xr-x   13 raojunbo  staff     416 11 30 11:39 hooks
-rw-r--r--    1 raojunbo  staff  391258 12 20 22:48 index
drwxr-xr-x    3 raojunbo  staff      96 11 30 11:39 info
drwxr-xr-x    4 raojunbo  staff     128 11 30 11:42 logs
drwxr-xr-x  256 raojunbo  staff    8192 12 14 14:58 objects
-rw-r--r--    1 raojunbo  staff    1536 11 30 11:42 packed-refs
drwxr-xr-x    5 raojunbo  staff     160 11 30 11:42 refs
</code></pre>

<ul>
<li><p>HEAD 文件<br/>
存有当前分支的头指针。在切换分支的时候，会跟随分支的变化而变化。当然也可以不与分支挂钩，直接指向一个处理分支状态（任意指向的）也可以。</p></li>
<li><p>config 文件</p>

<p><code>git config -l</code>命令的内容</p></li>
</ul>

<ul>
<li><p>ORIG_HEAD 文件</p></li>
<li><p>FETCH_HEAD 文件</p></li>
<li><p>object目录<br/>
对象集，block ,commit,tree,tags;</p></li>
<li><p>refs</p></li>
</ul>

<blockquote>
<p>git内部的命令<br/>
查看hash所代表的对象类型 `<code>git cat-file -t 005642f3c41eecb8c56b8b77c4f100f1575ccf54</code></p>

<p>查看hash所代表的对象实际内容<code>git cat-file -p 005642f3c41eecb8c56b8b77c4f100f1575ccf54</code></p>
</blockquote>

<h2 id="toc_1">commit,tree,block关系</h2>

<p><img src="media/15453592839286/gitbloctree.png" alt="gitbloctree"/></p>

<p>blob实际就是真实的文件<br/>
tree实际就是目录<br/>
commit是git里的东西是一个包含“根tree”的东西。commit里有parent(父commit),author(作者),committer(提交者)</p>

<h2 id="toc_2">分离头指针情况的注意事项（没有与branch进行关联）</h2>

<pre><code>➜  GitTestDir git:(master) git checkout 552aa3eba30936d5c4ecf148b38d0cbc89221fbc 
Note: checking out &#39;552aa3eba30936d5c4ecf148b38d0cbc89221fbc&#39;.

You are in &#39;detached HEAD&#39; state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b &lt;new-branch-name&gt;

HEAD is now at 552aa3e add sty
➜  GitTestDir git:(552aa3e) 
</code></pre>

<p>直接切换到一个指定的commit号，直接进入工作后，进行提交，如果在checkout 到其它分支，就会出现分离头指针，也就是没有基于某个分支。在后期，分支的指针会自动被清理掉。</p>

<p>git diff HEAD HEAD^     //head与父亲进行对比<br/>
git diff HEAD HEAD<sup>^</sup>   //head 与父亲的父亲进行对比<br/>
git diff HEAD HEAD~1    //head 与父亲进行对比</p>

<h2 id="toc_3">修改commit的message</h2>

<p>对最近一次的message做修改<br/>
<code>git commit --amend</code></p>

<h2 id="toc_4">rebase操作</h2>

<h3 id="toc_5">修改以往的任何一个commit的message(rebase)</h3>

<p>示例<br/>
<code><br/>
commit3<br/>
commit2<br/>
commit1<br/>
</code><br/>
我现在要，修改commit2,那么我就是git rebase -i commit1;以commit1作为基准,去修改其后面的commit信息。<br/>
rebase 命令的交互命令里有拿出commit,重新设置messge等操作。<br/>
修改后commit的commit号会发生变化。</p>

<h3 id="toc_6">合并以往的连续的几个commit（rebase）</h3>

<p>示例<br/>
<code><br/>
commit4<br/>
commit3<br/>
commit2<br/>
commit1<br/>
</code><br/>
合并commit2,与commit3为commit5;这样就会形成一个新的commit;</p>

<h3 id="toc_7">合并以往的不连续的commit(rebase)</h3>

<p>其实与前面一样，只是，列出commit ，然后描述命令</p>

<h2 id="toc_8">diff操作</h2>

<ul>
<li><p>比较工作区，索引区,HEAD的差异<br/>
<code>git diff --cached</code>  比较索引区域HEAD的差别比较<br/>
<code>git diff</code> 工作区与索引区的差别</p></li>
<li><p>比较不同分支的同一个文件的差异</p></li>
</ul>

<p><code>git diff temp master -- filename</code><br/>
temp是一个分支或者commitid，master是一个分支或者commitid；</p>

<h2 id="toc_9">恢复工作区，恢复索引区</h2>

<ul>
<li>清空工作区</li>
</ul>

<p><code>git checkout file</code><br/>
<code>git checkout .</code></p>

<ul>
<li>将加入索引的放入工作区</li>
</ul>

<p><code>git reset HEAD</code></p>

<ul>
<li>清除最近的几个commit</li>
</ul>

<p><code>git reset --hard  commitid</code></p>

<h2 id="toc_10">删除，重命名文件</h2>

<ul>
<li>重命名文件
<code>git mv filename1 filename2</code></li>
</ul>

<ul>
<li>删除文件
<code>git rm filename</code></li>
</ul>

<h2 id="toc_11">ignore文件</h2>

<p><code>.gitignore</code>告诉哪些不需要加入git的管理里</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15448598664160.html">网络协议总结</a></h1>
			<p class="meta"><time datetime="2018-12-15T15:44:26+08:00" 
			pubdate data-updated="true">2018/12/15</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">网络协议层次</h2>

<p>应用层：HTTP,HTTPS,RTMP,DHCP,DNS,P2P<br/>
传输层：TP，UDP<br/>
网络层：IP,ICMP,OSPF,BGP<br/>
链路层：ARP,VLAN,STP<br/>
物理层</p>

<h2 id="toc_1">2层设备，3层设备</h2>

<h2 id="toc_2">IP</h2>

<h3 id="toc_3">IP组成</h3>

<p>IP地址由网络地址和主机地址共同组成。下面两种分类方法去定义IP的网络地址与主机地址。<br/>
- 传统地址分类<br/>
A,B,C,D类，现在基本不用</p>

<ul>
<li>无类型域间选路即CIDR（<strong>目前采用的方案，泳衣解决传统分类IP浪费的问题</strong>）

<ul>
<li>子网掩码的表示形式</li>
<li>16.158.165.91/22</li>
</ul></li>
</ul>

<h3 id="toc_4">公有IP地址和私有IP地址</h3>

<p>将<code>192.168.0.0~192.168.255.255</code>之间的地址定义为私有地址。也就是在同一公有IP的网络里唯一，在不同的IP网络里可能相同。这样在结合NAT技术解决通讯问题。<strong>这是目前采用的方案，用以解决IP即将耗尽的问题</strong></p>

<h2 id="toc_5">动态主机配置协议(DHCP)</h2>

<h2 id="toc_6">ARP协议</h2>

<ul>
<li><p>集线器<br/>
全部是用广播</p></li>
<li><p>交换机<br/>
刚开始是广播，通过自学习能力的完善转发表，知道了到达的MAC地址的设备口。就可以定向转发。</p></li>
</ul>

<h2 id="toc_7">ICMP协议</h2>

<p><img src="media/15448598664160/23aecf653d60dd94b7c5c6dc21ca21ff.jpg" alt="23aecf653d60dd94b7c5c6dc21ca21ff"/></p>

<ul>
<li><p>ping <br/>
就是利用ICMP协议的<strong>查询报文</strong></p></li>
<li><p>traceroute<br/>
就是利用ICMP的<strong>差错报文</strong></p></li>
</ul>

<h2 id="toc_8">公有IP与私有IP的应用</h2>

<p>有NAT路由设备，将公有IP映射成私有IP,进关,将私有IP映射成公有IP，出关。此种模式就是”玄奘西行&quot;，在出关时需要换成公有IP。即很多路由器支持的NAT转换。这里的公网就是运营商的地址。<br/>
那么这个这里有个疑问，isp服务商</p>

<h2 id="toc_9">路由协议</h2>

<ul>
<li>静态路由策略（手动配置）</li>
<li>动态路由算法(自动配置)
距离矢量路由算法,基于距离矢量路由算法的BGP
链路状态路由算法,基于链路状态路由算法的OSPF</li>
</ul>

<h2 id="toc_10">传输层</h2>

<p>UDP与TCP的区别<br/>
所谓的建立连接，是为了在客户端和服务端连接，而建立一定的数据结构来维护双方交互的状态(连接实际上就是<strong>连接就是两端的状态维护</strong>)。用这样的数据结构来保证所谓的面向连接的特性。<br/>
TCP提供可靠交付。保证数据的无差错，不丢失，不重复，并按顺序到达。<strong>是一种由状态的服务</strong>。提供拥塞控制。</p>

<p>UDP<br/>
UDP继承了IP数据报的原始特性，一个个发一个个地接收。不管网络情况，一个劲的发。</p>

<ul>
<li>UDP
<img src="media/15448598664160/6d1313f51b9dfd7ab454b2cef1cb37bf.jpg" alt="6d1313f51b9dfd7ab454b2cef1cb37bf"/></li>
</ul>

<p>UDP的几个例子<br/>
1. Google推出的QUIC是基于UDP改进的通信协议，其目的是降低网路通信的延迟<br/>
2. 很多直播都会基于UDP实现自己的视频传输协议<br/>
3. 很多实时游戏会采用自定义的可靠UDP协议，来自定义重传策略，将丢包降低到最低<br/>
4. 物联网，很多嵌入式设备不能处理打量的数据结构，基于UDP实现网络通信</p>

<ul>
<li>TCP
<img src="media/15448598664160/a795461effcce686a43f48e094c9adbf.jpg" alt="a795461effcce686a43f48e094c9adbf"/>
TCP的三次握手
为什么是三次握手：保证双方的消息都<strong>有去有回</strong>。就是建立连接了。</li>
</ul>

<p>TCP的四次分手<br/>
分手过程，要保证各端的数据都发送完了。才真正结束。</p>

<p>顺序问题<br/>
超时重传<br/>
流量控制<br/>
拥塞控制</p>

<h2 id="toc_11">应用层协议</h2>

<ul>
<li>HTTP</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15444947240000.html">C语言拾遗</a></h1>
			<p class="meta"><time datetime="2018-12-11T10:18:43+08:00" 
			pubdate data-updated="true">2018/12/11</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>
<a href="#toc_0">一：编译</a>
<ul>
<li>
<a href="#toc_1">makefile的编译</a>
</li>
<li>
<a href="#toc_2">预处理</a>
<ul>
<li>
<a href="#toc_3">条件编译</a>
</li>
<li>
<a href="#toc_4">预定义宏</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">完整项目多文件编译</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">二：指针的概念</a>
<ul>
<li>
<a href="#toc_7">指针与object的关系</a>
</li>
<li>
<a href="#toc_8">指针与数组的关</a>
</li>
<li>
<a href="#toc_9">指针与函数</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">三：C中的字符串</a>
</li>
<li>
<a href="#toc_11">四：C的内存管理</a>
<ul>
<li>
<a href="#toc_12">动态内存分配</a>
</li>
</ul>
</li>
<li>
<a href="#toc_13">五：结构体</a>
</li>
<li>
<a href="#toc_14">六：抽象数据接口</a>
</li>
<li>
<a href="#toc_15">七：示例</a>
</li>
</ul>


<h2 id="toc_0">一：编译</h2>

<p>不同的CPU制造商使用的指令系统和编码格式不同。例如Intel Corei7与ARM采用的就是不同的指令集。在编译时，编译器就需要将C语言编译成相应CPU的机器码。</p>

<p>补充说明：汇编语言是为特殊的CPU设计的一系列内部指令，是用助记符号表示，不同的CPU使用不同的汇编指令，就像C语言编译器编译成机器指令</p>

<p>C语言标准定义，C89,C99，C11（2011）等标准，而这种<strong>标准实际上是一种抽象</strong>。具体的实现是由相应的编译器解释。</p>

<blockquote>
<p>编译流程，把源代码文件转换为可执行文件，具体是首先把源代码转换成中间代码（这个中间代码是没有连接其他模块的代码，因为这个中间代码可能用到了其他模块的函数，这个模块可以是其他模块也可是标准库），连接器把中间代码和其他代码合并（这个合并的过程就是连接的过程，是模块之间能正常找到调用），最终生成可执行文件。</p>
</blockquote>

<p>GNU编译合集，LLVM项目分别是连个开源编译合集。都支持C的编译，在苹果系统目前采用LLVM项目里的Clang来编译C程序。</p>

<p>哈哈，从上述的整理，终于理解了Xcode里的Architectures（CPU架构），FrameSearchPath,Header SearchPath,Library SearchPath,Apple Clang的编译选项设置。</p>

<h3 id="toc_1">makefile的编译</h3>

<p>在编译一个开源的C库时，比如Objectc的runtime，编译FFmpeg的库时，都会用到makefile文件来进行构建。</p>

<p>make通常被视为一种软件构建工具，是一个命令行工具。该工具主要经由读取一种名为“makefile”或“Makefile”的文件来实现软件的自动化建构程序。makeFile有其自己的语法。</p>

<ul>
<li>文件包含</li>
</ul>

<p>include <stdio.h>的实质：实际上是相当于把stdio.h文件中的所有内容都输入该行所在的位置。</p>

<h3 id="toc_2">预处理</h3>

<pre><code>#define PI 3.13444
</code></pre>

<pre><code>//带固定参数个数的宏
#define Men(X,Y) ((X)+(Y))  
</code></pre>

<pre><code>//可变参数个数的宏
#define PR(...) printf(__VA_ARGS__) //可变参数的宏
PR(&quot;Howdy&quot;);
PR(&quot;weight=%d, shipping=%d&quot;,wt,sp);
</code></pre>

<pre><code>//文件包含
#include
当预处理器发现#include指令时，会替换源文件中的include指令。
（相当于把被包含的文件的全部内容输入到源文件#include指令所在的位置）
要深度的理解这句话的含义，包含，就是将代码实现替换到这。
头文件提供函数声明或者原型，库选项（也就是真正的库）告诉系统到哪里查找函数代码，或者是到源文件里查找代码。
</code></pre>

<ul>
<li>区分宏定义的函数与函数区别</li>
</ul>

<p>宏每调用一次，都会展开一次，是一种内联。而函数的调用。是会在一段函数指令里执行一次又一次。</p>

<h4 id="toc_3">条件编译</h4>

<pre><code>#define
#ifdef
#else
#endif
#ifndef
#if
#elif
</code></pre>

<h4 id="toc_4">预定义宏</h4>

<pre><code>C标准规定了一些预定义宏
__LINE__
__FILE__
__func__
</code></pre>

<h3 id="toc_5">完整项目多文件编译</h3>

<h2 id="toc_6">二：指针的概念</h2>

<p>从核心的去理解指针，就是一个<strong>地址值</strong>，一个变量的地址值。一个数组的首原始地址值。一个函数代码段的开始地址值。<br/>
指针的操作，是根据他们指向的数据的所占空间的大小来操作的。指向整数时，p+1,就是指向下一个整数。</p>

<pre><code>int *p1 //指向int的指针变量（理解成一个整形变量的地址）
double *p2;
</code></pre>

<ul>
<li>指针的应用</li>
</ul>

<p>有时候，在函数外有个数组，想通过，这个函数修改数组里的值，要将整个修改逻辑放在这里。就需要传地址。(但外面是一个结构体时，有时遇到需要通过一个函数修改这个结构体的值，也会采用传地址的方式)。这是一个非常典型的应用场景。</p>

<pre><code>//在采用传地址时，不允许修改这个数组的内容的值时，可以添加const。
//const修饰指针时，表示内容不允许修改
int sum (const int ar[],int n);
int sum (const int ar[],int n) {
    int i;
    int total = 0;
    for (int = 0;i&lt;n;i++){
        total =+=ar[i];
    }
    return total;
}
</code></pre>

<ul>
<li>const修饰的区别的理解</li>
</ul>

<pre><code>const double *pd1;
double *const pd2;
</code></pre>

<p>要区分这两个含义，要从本质上理解，pd1的const修饰的是double *pd1,也就是这个指针变量，这个整体是值。也就是值是常量。<br/>
而，pd2的const修饰的pd2这个地址。是这个指针。也就是指针是常量</p>

<pre><code>int val = 10;
const double *pd1 = &amp;val;
*pd1 = 20;//不允许(因为修改了指针所指向内容的值)
</code></pre>

<pre><code>double rate[] = {10,20,30};
double *const pc = rate;
 pc = &amp;rate[2];//不允许(因为是修改了指针的值)

</code></pre>

<p>哈哈，终于里理解了这个东西。</p>

<h3 id="toc_7">指针与object的关系</h3>

<p>指针与NSObject的关系，要从C的内存管理角度去思考。</p>

<h3 id="toc_8">指针与数组的关</h3>

<p>指针指向的就是数组的首地址。</p>

<h3 id="toc_9">指针与函数</h3>

<p>指向函数的指针中存储着函数代码的起始地址。</p>

<pre><code>void func (char *);
void (*pf) (cahr *);
pf 即是指向函数的指针
</code></pre>

<pre><code>void ToUpper(char *);
void ToLower(char *);
pf = ToUpper;//将函数地址赋值给函数指针
pf = ToLower;//将函数地址赋值给函数指针
(*pf)(&quot;nihao&quot;);//调用函数
</code></pre>

<h2 id="toc_10">三：C中的字符串</h2>

<ul>
<li>字符串常量</li>
</ul>

<p>这个字符串在编译的时候就已经确定。所以是在静态存储区。</p>

<pre><code>char *str = &quot;nihao&quot;;
//实际上&quot;nihao&quot;是一个字符数组。一个在末尾加了\0元素的字符数组。
</code></pre>

<ul>
<li><strong>数组形式</strong>与<strong>指针形式</strong>的不同</li>
</ul>

<p>字符串常量是在编译时就确定好的在静态存储区。</p>

<pre><code>const char ar[] = &quot;something1&quot;;
const char *p = &quot;something2&quot;;

对比说明:
&quot;something1&quot;是一个字符串常量，在给ar[]赋值时会将其拷贝到这个数组里。
&quot;something2&quot;是一个字符串常量，在静态存储区，在给*p赋值时，直接将静态区字符串的地址值给它。因为它是一个常量，内容没法修改，所以通常在前面加一个const;
</code></pre>

<h2 id="toc_11">四：C的内存管理</h2>

<p>三个维度描述变量<br/>
链接<br/>
作用域<br/>
存储区</p>

<p>链接，作用域描述变量的可见性<br/>
存储区，描述变量的存储位置</p>

<ul>
<li>外部变量</li>
</ul>

<p>（在一个源文件里，在所有函数之外的变量），作用域是本文件，存储是静态存储，链接默认是外部链接，<strong>如果用static修饰，就是内部链接。</strong></p>

<ul>
<li><p>局部变量</p>

<p>在块，函数里的是局部变量，作用域是块或者函数内，存储默认是栈上，链接是内部链接。<strong>但若用static修饰，就是存储在静态区。</strong></p></li>
</ul>

<p>extern 申明这个源文件使用了外部变量。（哈哈，这里才是extern的本质）</p>

<h3 id="toc_12">动态内存分配</h3>

<p>思考：为什么会有动态内存分配？<br/>
在我们的编译，执行时，<strong>根据已经制定好的内存管理规则，将自动选择作用域与存储区，自己管理内存（静态数据编译时分配，自动数据在执行时分配）</strong>。但，<strong>我们也可以程序员自己申请内存，自己释放内存，就是动态内存的分配。</strong></p>

<h2 id="toc_13">五：结构体</h2>

<p>结构体在实际的应用中相当重要。一些重要的库的数据描述都是用结构体表示。与结构体指针一同构建起一个大的程序库。比如objc-runtime,ffmpeg库。</p>

<pre><code>struct book {
    char title[10];
    char author[20];
    float value;
} abook;
book 是类型，abook是变量名
</code></pre>

<p>将结构体类型当做普通的变量类型就可以了。</p>

<pre><code>struct book aBook;  //结构变量
struct book *b;     //指向结构的指针
aBook.value;//取值
b-&gt;value;//取值
</code></pre>

<ul>
<li>结构体了字符数组与字符指针表示的区别</li>
</ul>

<pre><code>struct names{
    char first[10];
    char last[10];
}
</code></pre>

<pre><code>struct pnames {
    char *first;
    char *last;
}
</code></pre>

<p>names占用20字节，pnames占用16字节。<br/>
names的本身存储位置是在它自己申请的位置。<br/>
pnames的first,last存存储在别处。用的时候要特别小心。</p>

<p>示例结构体内部字符指针表示的用法。（很重要）<br/>
下面是将结构体力的变量设置成字符指针。因为没有地方存储实际的值，所以需要用动态创建内存。</p>

<pre><code>struct namect {
    char *fname;
    char *lname;
}

void getinfo(struct namect *pst){
    char temp[20];
    scanf(&quot;%s&quot;,tmp);//将输入的暂时存入tmp
    pst-&gt;fanme= (char *)malloc(strlen(temp)+1);//动态创建一个空间
    strcpy(pst-&gt;fname,temp);//将tmp的拷贝到动态空间
}
</code></pre>

<h2 id="toc_14">六：抽象数据接口</h2>

<p>链表<br/>
队列</p>

<p>结语：至此关于C的一些核心概念就都搞清楚了。</p>

<h2 id="toc_15">七：示例</h2>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#define SLENGTH 80

struct namect {
    char *fname;
    char *lname;
    int letters;
};

typedef struct namect NAMEct;
//以下都是函数声明
//将结构体指针作为参数传递

void getinfo (struct namect *);
void makeinfo (struct namect *);
void showinfo (const struct namect *);
void cleanup (struct namect *);

char * s_gets(char *st ,int n);

int main () {
    NAMEct person;

    getinfo(&amp;person);
    makeinfo(&amp;person);
    showinfo(&amp;person);//显示信息
    cleanup(&amp;person);//调用该函数时释放内存
}

void getinfo (struct namect *pst){
    char temp[] = &quot;naihao&quot;;
    char temp2[] =  &quot;naihao2&quot;;

    pst-&gt;fname = (char *) malloc(strlen(temp) +1);//申请内存
    strcpy(pst-&gt;fname,temp);//将字符拷贝到生成的内存中

    pst-&gt;lname = (char *) malloc(strlen(temp2) +1);//申请内存
    strcpy(pst-&gt;lname,temp2);
}


void makeinfo (struct namect *pst){
    pst-&gt;letters = strlen(pst-&gt;fname) + strlen(pst-&gt;lname);
}

void showinfo(const struct namect *pst){
    printf(&quot;firstName:%s secondName:%s letters:%d&quot;,pst-&gt;fname,pst-&gt;lname,pst-&gt;letters);
}

void cleanup (struct namect *pst){
    free(pst-&gt;fname);//释放内存
    free(pst-&gt;lname);//释放内存
}



</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15443591203562.html">shell脚本知识梳理（八）文本处理</a></h1>
			<p class="meta"><time datetime="2018-12-09T20:38:40+08:00" 
			pubdate data-updated="true">2018/12/9</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>文本处理带真正用到时再研究吧。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15443590303184.html">shell脚本知识梳理 （六）函数</a></h1>
			<p class="meta"><time datetime="2018-12-09T20:37:10+08:00" 
			pubdate data-updated="true">2018/12/9</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">函数</h2>

<pre><code>#!/bin/bash
function testFunc(){
    echo $1:$2
    return 100;
}

echo &quot;调用前&quot;
testFunc &quot;rao&quot; &quot;jun&quot;;
echo &quot;返回结果$?&quot;
echo &quot;调用后&quot;
</code></pre>

<p>函数的传参数与在命令里的传参数基本相同。返回值用$?记录上次函数的返回值。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15443316930228.html">shell脚本知识梳理（零）linux 基础命令</a></h1>
			<p class="meta"><time datetime="2018-12-09T13:01:33+08:00" 
			pubdate data-updated="true">2018/12/9</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>
<a href="#toc_0">linux的文件权限</a>
</li>
<li>
<a href="#toc_1">Linux的文件与目录管理</a>
<ul>
<li>
<a href="#toc_2">目录操作</a>
</li>
<li>
<a href="#toc_3">文件操作</a>
</li>
<li>
<a href="#toc_4">查看文件</a>
</li>
<li>
<a href="#toc_5">查找文件名</a>
</li>
</ul>
</li>
</ul>


<p>shell的基础命令，列出已经掌握的基本命令</p>

<h2 id="toc_0">linux的文件权限</h2>

<pre><code>-rwxr--r--  1 raojunbo  staff   159 12  8 17:20 file2.sh
</code></pre>

<p><code>chmod</code> 改变文件的权限<br/>
<code>chown</code> 改变文件所有者<br/>
<code>chgrp</code> 改变文件所属用户</p>

<h2 id="toc_1">Linux的文件与目录管理</h2>

<p>ls 列出文件及目录列表<br/>
cd 进入目录<br/>
pwd 显示文件路径<br/>
touch 创建新文件<br/>
file 查看文件类型</p>

<h3 id="toc_2">目录操作</h3>

<p>mkdir<br/>
rmdir</p>

<h3 id="toc_3">文件操作</h3>

<p>cp<br/>
rm<br/>
mv</p>

<h3 id="toc_4">查看文件</h3>

<p>cat<br/>
more<br/>
less<br/>
head<br/>
tail</p>

<h3 id="toc_5">查找文件名</h3>

<p>whereis<br/>
locate<br/>
find</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15442673526076.html">shell脚本知识梳理（七）SQL应用处理</a></h1>
			<p class="meta"><time datetime="2018-12-08T19:09:12+08:00" 
			pubdate data-updated="true">2018/12/8</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>导出.cvs格式</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15441102869614.html">shell脚本知识梳理（五）输出</a></h1>
			<p class="meta"><time datetime="2018-12-06T23:31:26+08:00" 
			pubdate data-updated="true">2018/12/6</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>
<a href="#toc_0">echo</a>
</li>
<li>
<a href="#toc_1">printf 格式化输出</a>
</li>
<li>
<a href="#toc_2">管道</a>
</li>
<li>
<a href="#toc_3">重定向输出</a>
<ul>
<li>
<a href="#toc_4">命令行里的输入与输出重定向</a>
</li>
<li>
<a href="#toc_5">脚本文件里的输入与输出重定向</a>
</li>
<li>
<a href="#toc_6">自定义文件描述符</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">总结</a>
</li>
</ul>


<h2 id="toc_0">echo</h2>

<h2 id="toc_1">printf 格式化输出</h2>

<p>[TOC]<br/>
- 区别一<br/>
print不会自动换行<br/>
echo 会自动换行</p>

<ul>
<li>区别二
print 用于格式打印
echo 用于标准的输出</li>
</ul>

<pre><code>printf &quot;%-4s%-8s%-4s\n&quot; 姓名 性别 体重
printf &quot;%-4s%-8s%-4s\n&quot; raoraoraorao 男 120
printf &quot;%-4s%-8s%-4s\n&quot; jun 女 130
printf &quot;%-4s%-8s%-4s\n&quot; bo 女 140
</code></pre>

<p>格式化输出 &quot;s&quot;表示字符串，一个宽度是10的字符,如果超出也显示，不足10用空白不齐，”-“表示左对齐。</p>

<h2 id="toc_2">管道</h2>

<p>将一个命令的输出做威另一个命令的输入</p>

<h2 id="toc_3">重定向输出</h2>

<ul>
<li>
<a href="#toc_0">echo</a>
</li>
<li>
<a href="#toc_1">printf 格式化输出</a>
</li>
<li>
<a href="#toc_2">管道</a>
</li>
<li>
<a href="#toc_3">重定向输出</a>
<ul>
<li>
<a href="#toc_4">命令行里的输入与输出重定向</a>
</li>
<li>
<a href="#toc_5">脚本文件里的输入与输出重定向</a>
</li>
<li>
<a href="#toc_6">自定义文件描述符</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">总结</a>
</li>
</ul>


<p>原来是重定向到控制台输出，现在是重定向输出到文件</p>

<p>文件重定向<br/>
以控制台为参照<br/>
<strong>系统已经存在的文件描述符0（标准输入即键盘），1(标准输出即控制台)，2(标准错误)，其他是可自定义的文件描述符</strong></p>

<p>白话理解cat命令行重定向<br/>
原来是从键盘输入，现在是从文件输入<br/>
<code>cat</code> 命令直接输入cat命令，从键盘输入，然后在控制台输出。<br/>
<code>cat file</code> 采用cat接收一个非STDIN文件输入，即将输入变成从文件读取<br/>
特别说明</p>

<blockquote>
<p>重定向不限制于cat命令,任何命令都可以。<br/>
就是将一个命令的输出重定向到其他文件或者标准输出。在一个命令的输入时，也可以从一个文件或者标准输入作为输入，即输入重定向</p>
</blockquote>

<pre><code>“&gt; ” 重定向输出到一个文件
&quot;&gt;&gt;&quot; 重定向输出到一个文件并且是追加到后面
</code></pre>

<h3 id="toc_4">命令行里的输入与输出重定向</h3>

<p>案例一：重定向错误输出到一个文件中<br/>
    当我们的命令发生错误时，shell并不会将错误重定向到输出的重定向文件。重定向时要写上文件描述符</p>

<pre><code>ls -al fileC 2&gt; errfile.sh 
</code></pre>

<p>案例二：将正确信息重定向到一个文件，将错误信息重定向到一个文件</p>

<pre><code>ls -al fileA.sh fileC.sh 2&gt; errfile.sh 1&gt; fileD.sh
</code></pre>

<p>案例三：将正确与错误输入到同一个文件</p>

<pre><code>ls -al fileA.sh fileC.sh &amp;&gt;  fileD.sh 
</code></pre>

<h3 id="toc_5">脚本文件里的输入与输出重定向</h3>

<p>要想在脚本文件里指定文件的输入与输出重定向，需要对这个要输出的内容做标记。告诉要输入或者输出到哪个文件。那么这个文件的描述符就需要在脚本里写出</p>

<ul>
<li>临时重定向
这里的&amp;2是一种标记，标记其内容将会进入那个重定向，因为只起到临时标记的作用。所以叫临时重定向。这里的临时，永久是在脚本文件里告诉，命令的输入与输入。也就是在脚本文件里告诉有输出，有输入的一个流。</li>
</ul>

<pre><code># 临时重定向 在一个shell脚本里，将一个输出设置成临时重定向

echo &quot;hello owrk&quot; &gt;&amp;2;
echo &quot;你好&quot; &gt;&amp;2;
</code></pre>

<ul>
<li>永久重定向
这里的永久重定向，说白点就是一次性标记。</li>
</ul>

<pre><code>exec 1&gt; fileContent.sh
echo &quot;hello world&quot;
echo &quot;你好&quot;

# 更改为重定向
exec 2&gt; errorfile.sh
echo &quot;我报错了&quot; &gt;&amp;2   
# 将我报错了进行标记 
</code></pre>

<pre><code>exec 0&lt; fileContent.sh
# 读物文件的所有行
count=1;
while read line  
do
echo &quot;读取的内容${line},行数${count}&quot;;
count=`expr $count + 1`;
done
</code></pre>

<h3 id="toc_6">自定义文件描述符</h3>

<ul>
<li>创建文件读写描述符号示例</li>
</ul>

<pre><code>#创建文件的读写描述符
exec 3&lt;&gt; fileContent.sh

#读取文件中的一行数据
read line &lt;&amp;3

#打印数据
echo &quot;读取数据:&quot;$line;
echo &quot;哈哈，看写入文件了没wwwww有&quot; &gt;&amp;3
</code></pre>

<ul>
<li>关闭文件描述符 关闭文件描述符后，不能写入文件</li>
</ul>

<p><code>exec 3&gt;&amp;-</code></p>

<ul>
<li>恢复文件描述符(这个很难理解，实际上是一个暂存)</li>
</ul>

<pre><code># 创建一个文件描述符3，执行原有文件描述符1，也就是是控制台输出
exec 3&gt;&amp;1;

# 创建文件描述符1，重定向到一个文件
exec 1&gt; fileContent.sh

echo &quot;工作1&quot;;

echo &quot;工作2&quot;;

# 将1重定向到预先保存的控制台输出,所左这之后会输出都屏幕,也就是恢复了
exec 1&gt;&amp;3
echo &quot;完成了&quot;;

</code></pre>

<pre><code>修改输入并恢复输入
exec 6&lt;&amp;0;
exec 0&lt; fileContent.sh

# 系统还是会从0所指向的文件进行读取，输出还是原有的输出
while read line 
do
 echo &quot;文件内容${line}&quot;
done

exec 0&lt;&amp;6;

echo &quot;读取完成&quot;;
</code></pre>

<h2 id="toc_7">总结</h2>

<blockquote>
<p>0，1，2,是系统默认已经指定了的文件描述符，分别指向键盘文件，控台台文件，错误文件。exec的本质是在一个进程里创建一个文件描述符。在shell脚本里可以创建文件描述符指定特定的文件进行输入与输出。<br/>
文件描述符的理解，文件描述符只是一个符号</p>
</blockquote>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15440981221870.html">shell脚本知识梳理（三） 流程控制</a></h1>
			<p class="meta"><time datetime="2018-12-06T20:08:42+08:00" 
			pubdate data-updated="true">2018/12/6</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">if语句</h2>

<blockquote>
<p>这里的条件就是上节说的test命令的参数</p>
</blockquote>

<pre><code>if [ 条件 ]
then
    代码
fi
</code></pre>

<pre><code>if [ 条件]
then
    代码
else
    代码
fi
</code></pre>

<pre><code>if [ 条件 ]
then
    代码
elif [ 条件 ]
then
    代码
fi

</code></pre>

<h2 id="toc_1">for语句</h2>

<pre><code>for 变量名 in item1 item2 item3
do
    代码    
done
</code></pre>

<pre><code>for name in &quot;rao&quot; &quot;jun&quot; &quot;bo&quot;
do
    echo ${name}
done    
</code></pre>

<pre><code>//列出当前目录所有文件(用的for in)
file=`pwd`/*;
for name in ${file}
do
    echo ${name}
done
</code></pre>

<pre><code>//for 的c形式
for (( i = 0; i &lt; 10; i++ )); do
    echo $i;
    for (( j = 0; j &lt; 10; j++ )); do
        echo $j;
    done
done
</code></pre>

<pre><code>//一个一个显示文件列表
for i in `ls `
do
echo &quot;这是文件${i}&quot;;
done
</code></pre>

<h2 id="toc_2">while</h2>

<pre><code>while [] 
do

done
</code></pre>

<pre><code>//示例
var=10;
while [ ${var} -gt 0 ];
do
echo $var;
var=`expr ${var} - 1`;
done
</code></pre>

<h2 id="toc_3">switch case</h2>

<pre><code>number=1
case $number in
    1) echo &quot;等于1&quot;;;
    2) echo &quot;等于2&quot;;;
esac
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15440910992060.html">shell脚本知识梳理（二）test命令的条件</a></h1>
			<p class="meta"><time datetime="2018-12-06T18:11:39+08:00" 
			pubdate data-updated="true">2018/12/6</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>
<a href="#toc_0">算术运算</a>
</li>
<li>
<a href="#toc_1">算术运算bc（浮点解决方案）</a>
<ul>
<li>
<a href="#toc_2">bc基本用法</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">数值比较运算</a>
</li>
<li>
<a href="#toc_4">布尔运算</a>
</li>
<li>
<a href="#toc_5">逻辑运算</a>
</li>
<li>
<a href="#toc_6">字符串运算符</a>
</li>
<li>
<a href="#toc_7">文件测试运算符</a>
</li>
</ul>


<h2 id="toc_0">算术运算</h2>

<pre><code>a=1;
b=2;
c=`expr ${a} + ${b}`;
d=`expr ${a} - ${b}`;
e=`expr ${a} \* ${b}`;
f=`expr ${a} / ${b}`;
echo $c;
echo $d;
echo $e;
echo $f;
</code></pre>

<pre><code>a=1;
b=1;

if [ ${a} != ${b} ]
    then
    echo &quot;a不相等b&quot;
fi


if [ ${a} == ${b} ]; then
    echo &quot;a相等b&quot;
fi
</code></pre>

<pre><code>a=100;
b=200;
val=`expr $a + $b`;//这个算是最标准的写法吧
echo $val;
</code></pre>

<pre><code>a=100;
b=200;
val=$(expr $a + $b);
echo $val;
</code></pre>

<pre><code>a=100;
b=200;
val=$[ $a + $b ];
echo $val;
</code></pre>

<p>特别说明，上述的拿到一个命令的输出值用一个变量去接收。可以有三种写法。但通常还是低一种写法<br/>
特别说明expr即运算表达式计算命令。在命令行里可以直接执行。实际上expr永远不止，运算表达式。里面也可以是关系表达式，逻辑表达式，字符串表达式。只不过shell的的运算比较弱，需要借助这个命令行工具来实现计算。</p>

<h2 id="toc_1">算术运算bc（浮点解决方案）</h2>

<p>在做运算时，可以用expr也可以用bc计算器。bc实际是一个专门的命令。在脚本中，将其当做普通命令就可以了，即使用命令替换就可以得到结果。bc 的输入实际是一个表达式.</p>

<h3 id="toc_2">bc基本用法</h3>

<p>bc计算器<br/>
数字，整数，浮点数<br/>
示例<br/>
直接在命令行输入：bc命令,然后进行计算<br/>
解释一下bc命令：在shell脚本语言中提示符下通过bc命令访问bc计算。相当于打开计算器。</p>

<p>quit退出计算器</p>

<ul>
<li>bc 在脚本中的应用</li>
</ul>

<pre><code>val1=1.314;
val2=0.618;
val3=`echo &quot;$val1 * $val2&quot; | bc`;
val4=`echo &quot;$val3 * $val2&quot; | bc`;
echo $val4;
</code></pre>

<ul>
<li>bc的输入重定向之打包计算</li>
</ul>

<pre><code>val=$(bc &lt;&lt; fg
    options
    statements
    expression
    fg
)
</code></pre>

<pre><code>val1=1.314;
val2=0.618;
val3=100;
val4=100;
val=$(bc &lt;&lt; fg
    a=($val1 *$val2)
    b=($val3 *$val4)
    a * b
    fg
)
echo &quot;val结果:${val}&quot;;
</code></pre>

<h2 id="toc_3">数值比较运算</h2>

<blockquote>
<p>特别说明<br/>
这里说的数值运算，布尔运算，逻辑运算，字符串比较运算，文件测试运算实际上都是<code>test</code>命令的条件参数，实际就是<code>test 条件参数</code>的返回结果，在分支语句中都是通过<code>test</code>来计算的。只不过为了简便，分支语句将test 用[] 等替换了。</p>
</blockquote>

<pre><code>-eq 检测两个数是否相等（equal）;
-ne 检测两个数是否相等(not equal)，不相等时返回true;
-gt  检测左边的数是否大于右边的数（greater）
-lt 小于
-elt 小于等于(equal or less than)
</code></pre>

<h2 id="toc_4">布尔运算</h2>

<pre><code>! 非运算
-O 或运算(or)
-a 与运算(and)
</code></pre>

<pre><code>a=10;
b=20;
if [ $a != $b ]
    then
    echo &quot;a 于b 不相等&quot;;
fi
if [ $a -lt 100 -a $b -gt 15 ]
    then
    echo &quot;$a 小于100,并且$b 大于15&quot;;
fi
</code></pre>

<h2 id="toc_5">逻辑运算</h2>

<p><code>&amp;&amp;</code>逻辑且<br/>
<code>||</code>逻辑或</p>

<pre><code>a=10
b=20

if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]
then
   echo &quot;返回 true&quot;
else
   echo &quot;返回 false&quot;
fi
</code></pre>

<h2 id="toc_6">字符串运算符</h2>

<pre><code>= 两字符串是否相等，相等返回true
!= 两字符串是否相等,不相等返回true
-z 字符串长度是否为0(zero)
-n 字符串长度是否为0
</code></pre>

<h2 id="toc_7">文件测试运算符</h2>

<p><img src="media/15440910992060/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-12-06%2011.47.58.png" alt="屏幕快照 2018-12-06 11.47.58"/></p>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="软件工程_2.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="软件工程.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E5%89%8D%E8%A8%80.html"><strong>前言&nbsp;(1)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E4%B8%AA%E4%BA%BA%E7%B3%BB%E7%BB%9F.html"><strong>个人系统&nbsp;(8)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E6%8A%95%E8%B5%84%E7%AC%94%E8%AE%B0.html">投资笔记&nbsp;(7)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B.html"><strong>软件工程&nbsp;(49)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="%E7%AE%97%E6%B3%95.html">算法&nbsp;(8)</a>&nbsp;&nbsp;
	        
	        	<a href="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.html">网络协议&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.html">iOS基础概念&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%BC%80%E6%BA%90%E5%88%86%E6%9E%90.html">iOS开源分析&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html">iOS性能优化&nbsp;(6)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E5%B7%A5%E5%85%B7%E6%B7%B1%E5%85%A5.html">iOS工具深入&nbsp;(2)</a>&nbsp;&nbsp;
	        
	        	<a href="shell%E8%84%9A%E6%9C%AC.html">shell脚本&nbsp;(9)</a>&nbsp;&nbsp;
	        
	        	<a href="C%E8%AF%AD%E8%A8%80%E6%8D%A1%E6%BC%8F.html">C语言捡漏&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Git%E5%B7%A5%E5%85%B7.html">Git工具&nbsp;(3)</a>&nbsp;&nbsp;
	        
	        	<a href="iOS%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html">iOS架构设计&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="Swift.html">Swift&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式&nbsp;(4)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	  
	      <li class="post">
	        <a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E6%8A%80%E6%9C%AF.html"><strong>音视频技术&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15512048926912.html">设计模式系列（四）-- 行为型</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15512048797799.html">设计模式系列（三）-- 结构型</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15512048653711.html">设计模式系列（二）--创建型设计模式</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15512048416439.html">设计模式系列（一）设计模式概要</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15512046578708.html">Swift梳理</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>